# SiteBender MVP Charter

## Vision
Enable non-coders to build real web apps by composing a tiny, semantic JSX DSL. The system compiles this into a unified IR that deterministically drives UI, validation, and semantic data artifacts. The complexity (state, accessibility, persistence, and RDF/SHACL) stays behind the curtain.

## MVP Scope (thin, end-to-end)

- Vocabulary
  - Page, Heading, Text, Divider, Block, Sidebar (aside), Header, Footer, Template
  - Form with fields: ChooseOneField, IntegerField, SubmitButton
    - But for forms auto-generated by the schema, just <Field name="size" /> should be enough
  - Vault/Collection/Item/Field, Calculation, From.Value, From.Constant
  - Control flow: When, Then, Else; Logic: Is.Equal; Operators: Add, Multiply
- Compiler
  - JSX markers → validated Adaptive IR (deterministic)
  - IR → runtime graph (evaluation of Calculations, bindings for Form fields)
  - IR → stub SHACL/ontology artifacts (files on disk) for future backend work
- Runtime
  - In-memory state model with reactive recomputation
  - Client-side validation derived from IR (required, min/max for IntegerField)
  - Submit captures current state to JSON (local log/persist), surfacing validation errors
- Tooling
  - Jexer-based playground with three panes: JSX (editable), IR (readonly), Live View
  - “Explain” panel showing compiler transform steps and rationale (stub ok)

## Non-Goals (for MVP)

- Offline-first sync, CRDTs, or distributed triplestore
- Plugin system or user-defined components
- Full ontology editing/merging; migrations
- Rich field catalog (keep 3–5 core fields)

## Success Criteria

- Deterministic compilation: same input → same IR, verified in tests
- Live reactive recomputation across Calculations in playground
- Friendly, source-mapped diagnostics for common DSL mistakes
- Accessibility invariants (headings, form labels) enforced via compiler/runtime tests

## Architectural Principles

- Small public DSL, strong IR: Prefer compiler passes to adding new DSL surface
- No JS in DSL: Expressions are trees of markers/constructors only
- Inspectability: Every transform can emit an explanation for tooling/AI
- Boundary-first: Clear storage/runtime interfaces to enable future backends

## Milestones and Deliverables

1) Contracts & IR hardening (Week 1)
- Add/Multiply/Is.Equal contracts; extend Matches as needed
- Deterministic node IDs and stable print for snapshot tests
- Unit tests for node kinds, op args, comparator args

2) Minimal DSL wrappers (Week 1–2)
- Page, Heading, Text, Divider, Form.*, Vault/Collection/Item/Field, Calculation, When/Then/Else, From.*
  - Note: I am leaning toward using If/Is.True/Is.False instead and then using the When namespace for event handling, e.g., When.Clicked, When.HoveredOver, When.Submitted, When.Focused, When.FocusLost, When.InputChanged.
  - This could make If work like a switch: Is.Isbn10, Is.Isbn13, Is.PlainDate, etc.
- Ensure wrappers return plain markers; no runtime logic in JSX layer

3) Compiler E2E (Week 2)
- Lower markers → IR; validate arity/types; attach source ranges
- Generate friendly diagnostics with locations and hints

4) Runtime graph + evaluator (Week 2–3)
- In-memory state with subscriptions
- Evaluators for Add/Multiply; comparator Is.Equal; When/Then/Else selection
- Field bindings and validation wiring

5) Playground (Week 3)
- Editable JSX → show IR JSON → render live preview
- Explanation tab with transform steps (stub data allowed)

6) Docs & samples (Week 3)
- One-page tutorial built with the same components
- T-Shirt example demonstrating Calculations + Form

7) Integration & hygiene (ongoing)
- Strict tests wired per package (adaptive, components, jexer, toolkit)
- Type-check and alias guard green; CI task aggregation

## Integration & hygiene backlog (status)

- Type-check fully green (strict mode)
  - Status: Partial — workspace type-check passes; strict test tasks exist and pass. Non-strict tasks remain for dev speed.
  - Next: Ensure strict tasks run in CI; keep fast tasks local-only.

- Adaptive types unification (@adaptiveTypes)
  - Status: Todo — not yet enforced as single source or generated; no guard test.
  - Next: Pick source-of-truth (static or generated), remove duplication, add divergence guard test.

- Enforce alias imports repo-wide
  - Status: Partial — alias guard task exists (lint:aliases) and passes locally; not yet CI-blocking.
  - Next: Wire into CI and fail on violations; integrate with sortImports for autofix.

- Clean up implicit anys in Adaptive constructors
  - Status: Partial — some fixes (e.g., Matches typing, IR contracts) landed; families like Map/Set need Operand + datatype typing.
  - Next: Migrate remaining constructors; add 2–3 smoke tests per family.

- Property-based tests for laws/invariants
  - Status: Partial — widely used in toolkit; present in adaptive in a few spots.
  - Next: Add comparator/operator invariants under test:adaptive (e.g., symmetry, reflexivity, bounds).

- IR contract hardening
  - Status: Partial — added contracts for Subtract/Divide/Matches; components compiler handles Matches pattern/flags.
  - Next: Define lightweight schema/TS assertion tests for all node kinds; expand coverage across constructors and component compilation.

- CI regression guard
  - Status: Todo — no workflow yet.
  - Next: Add CI workflow running fmt, lint, type-check, and strict tests (adaptive/components/toolkit); make alias guard blocking.

## Risks & Mitigations

- Expressivity creep: Gate additions behind IR contracts and tests; freeze DSL list for MVP
- Debuggability: Build a simple inspector early (dataflow panel in playground)
- Error clarity: Author diagnostics alongside each compiler rule; snapshot them in tests

## Exit Criteria for MVP

- All milestone deliverables done
- Green strict test suites; reproducible builds
- Usable playground demo for the T-Shirt page, with working calculations and validation
