{
  "metadata": {
    "phase": "2.5",
    "encoding_type": "example",
    "created": "2025-10-03T05:37:10Z",
    "description": "Compliant code examples with context and rationale. Shows the correct way with explanation of why it's correct and when to use it."
  },
  "constitutional_rules": [
    {
      "rule_id": "const-001-no-classes",
      "category": "constitutional",
      "severity": "blocking",
      "example": "Module-based organization with pure functions. Define types in types.ts, create pure functions in separate files (createUser.ts, findUser.ts, addUser.ts). Each function operates on immutable data and returns new values. State is explicit and passed as parameters. No hidden dependencies or mutable instance state.",
      "context": "Module-based organization is the foundation of functional programming in TypeScript. Instead of classes with mutable state, we use modules containing pure functions that operate on immutable data.",
      "keywords": ["modules", "pure-functions", "no-classes", "functional"],
      "tags": ["example", "modules", "organization", "correct"]
    },
    {
      "rule_id": "const-002-no-mutations",
      "category": "constitutional",
      "severity": "blocking",
      "example": "Immutable operations using spread operators and const. For objects: {...obj, field: newValue}. For arrays: [...array, item] to add, [...array.slice(0, i), ...array.slice(i+1)] to remove. For nested: {...user, profile: {...user.profile, name}}. All variables const, all types Readonly.",
      "context": "Immutability eliminates bugs from unexpected state changes. Every operation returns a new value, making data flow explicit and predictable.",
      "keywords": ["immutability", "const", "spread", "readonly"],
      "tags": ["example", "immutability", "data-structures", "correct"]
    },
    {
      "rule_id": "const-003-no-loops",
      "category": "constitutional",
      "severity": "blocking",
      "example": "Functional iteration: map for transform, filter for selection, reduce for accumulation. Chain operations with pipe. Use recursion for custom iteration. All operations return new arrays, no mutations. Named functions for clarity.",
      "context": "Functional iteration is declarative and composable. Each operation is a pure function that can be tested independently and combined with others.",
      "keywords": ["map", "filter", "reduce", "iteration", "functional"],
      "tags": ["example", "iteration", "functional", "correct"]
    },
    {
      "rule_id": "const-004-no-exceptions",
      "category": "constitutional",
      "severity": "blocking",
      "example": "Error as value: Result<T,E> for fail-fast, Validation<T,E> for accumulation, Promise<Result<T,E>> for async. Define error types with _tag. Use ok/error constructors. Handle with matchResult. try-catch ONLY at effect boundaries when calling external APIs.",
      "context": "Representing errors as values makes error handling explicit, composable, and type-safe. Result for fail-fast, Validation accumulates errors, Promise<Result> for async.",
      "keywords": ["Result", "Validation", "error-as-value", "Promise<Result>"],
      "tags": ["example", "error-handling", "Result", "correct"]
    }
  ],
  "functional_programming_rules": [
    {
      "rule_id": "fp-001-pure-functions",
      "category": "functional_programming",
      "severity": "blocking",
      "example": "Pure functions: same input always gives same output, no side effects. No I/O, no mutations, no global state, no external dependencies. Deterministic and testable. Safe to memoize and parallelize.",
      "context": "Pure functions are predictable, testable, and composable. They make code easier to reason about and eliminate bugs from side effects.",
      "keywords": ["pure", "deterministic", "no-side-effects", "testable"],
      "tags": ["example", "purity", "functional", "correct"]
    },
    {
      "rule_id": "fp-002-immutability",
      "category": "functional_programming",
      "severity": "blocking",
      "example": "Immutable data: const for all variables, Readonly<T> for objects, ReadonlyArray<T> for arrays. Use spread operators for updates. Never mutate parameters or return values.",
      "context": "Immutability makes code predictable and eliminates bugs from unexpected state changes. Safe to share data across functions.",
      "keywords": ["immutable", "const", "readonly", "ReadonlyArray"],
      "tags": ["example", "immutability", "type-safety", "correct"]
    },
    {
      "rule_id": "fp-003-total-functions",
      "category": "functional_programming",
      "severity": "warning",
      "example": "Total functions handle all inputs. Use Maybe<T> for optional values, Result<T,E> for operations that can fail, Validation<T,E> for accumulating errors. Never return undefined/null without encoding in type.",
      "context": "Total functions eliminate runtime errors from unexpected undefined/null. Make function contracts explicit in types.",
      "keywords": ["total", "Maybe", "Result", "Validation", "exhaustive"],
      "tags": ["example", "totality", "type-safety", "correct"]
    },
    {
      "rule_id": "fp-004-function-composition",
      "category": "functional_programming",
      "severity": "advisory",
      "example": "Compose functions with pipe (left-to-right) or compose (right-to-left). Build complex from simple. Each function does one thing well. Data-last currying enables composition.",
      "context": "Composition builds sophisticated behavior from simple, well-tested building blocks. Makes data transformations explicit and readable.",
      "keywords": ["composition", "pipe", "compose", "combinator"],
      "tags": ["example", "composition", "functional", "correct"]
    },
    {
      "rule_id": "fp-005-higher-order-functions",
      "category": "functional_programming",
      "severity": "advisory",
      "example": "Higher-order functions take or return functions. Use for abstraction and code reuse. Common examples: map, filter, reduce, curried functions. Parameterize behavior instead of duplicating code.",
      "context": "HOFs enable powerful abstractions and declarative programming. Reuse behavior through parameterization.",
      "keywords": ["higher-order", "HOF", "map", "filter", "curry"],
      "tags": ["example", "higher-order-functions", "functional", "correct"]
    }
  ],
  "syntax_rules": [
    {
      "rule_id": "syntax-001-no-arrow-functions",
      "category": "syntax",
      "severity": "blocking",
      "example": "Named function declarations: function name(params): ReturnType { body }. For curried: inner functions include captured params in name. For callbacks: use named functions. Improves debugging and readability.",
      "context": "Named functions make stack traces readable and code self-documenting. Essential for debugging and understanding code flow.",
      "keywords": ["function", "named", "declaration", "no-arrow"],
      "tags": ["example", "syntax", "functions", "correct"]
    },
    {
      "rule_id": "syntax-002-no-abbreviations",
      "category": "syntax",
      "severity": "warning",
      "example": "Full descriptive names: calculateMaximumValue not calcMaxVal. Whitelist: id, html, url, uri, api, ast, ir, dsl. Code should read like plain English.",
      "context": "Full names make code self-documenting and reduce cognitive load. Abbreviations save characters but cost comprehension.",
      "keywords": ["full-names", "descriptive", "no-abbreviations"],
      "tags": ["example", "naming", "readability", "correct"]
    },
    {
      "rule_id": "syntax-003-plain-english-names",
      "category": "syntax",
      "severity": "warning",
      "example": "Names readable as natural language: getUserByEmailAddress, isUserAccountActive, calculateTotalPriceWithTax. Express intent clearly. Avoid cryptic or clever names.",
      "context": "Plain English names make code self-documenting. Good names answer what the thing is, what it does, or why it exists.",
      "keywords": ["plain-english", "readable", "clear-intent"],
      "tags": ["example", "naming", "readability", "correct"]
    },
    {
      "rule_id": "syntax-004-curried-function-naming",
      "category": "syntax",
      "severity": "advisory",
      "example": "Curried naming: function add(augend) { return function addToAugend(addend) { return augend + addend } }. Inner functions include captured parameters in their names.",
      "context": "Including captured parameters in inner function names makes closure behavior explicit and improves stack traces.",
      "keywords": ["currying", "closure", "naming", "captured-parameters"],
      "tags": ["example", "naming", "currying", "correct"]
    }
  ],
  "formatting_rules": [
    {
      "rule_id": "format-001-character-encoding",
      "category": "formatting",
      "severity": "blocking",
      "example": "UTF-8 without BOM. Configure in .editorconfig: charset = utf-8. VSCode: files.encoding = utf8. Git: text=auto eol=lf charset=utf-8.",
      "context": "UTF-8 is the universal standard ensuring compatibility across all platforms and tools.",
      "keywords": ["UTF-8", "encoding", "charset"],
      "tags": ["example", "encoding", "formatting", "correct"]
    },
    {
      "rule_id": "format-002-line-endings",
      "category": "formatting",
      "severity": "blocking",
      "example": "LF (Unix) line endings. Configure in .editorconfig: end_of_line = lf. Git: core.autocrlf = input. .gitattributes: * text=auto eol=lf.",
      "context": "LF ensures consistent behavior across platforms. Prevents diff noise and merge conflicts.",
      "keywords": ["LF", "line-endings", "eol"],
      "tags": ["example", "line-endings", "formatting", "correct"]
    },
    {
      "rule_id": "format-003-indentation",
      "category": "formatting",
      "severity": "blocking",
      "example": "Tabs for code (indent_style = tab, indent_size = 2). Spaces for markdown/YAML (indent_style = space, indent_size = 2). Never mix tabs and spaces.",
      "context": "Tabs allow developers to choose visual width while maintaining consistent logical structure.",
      "keywords": ["tabs", "spaces", "indentation"],
      "tags": ["example", "indentation", "formatting", "correct"]
    },
    {
      "rule_id": "format-004-line-length",
      "category": "formatting",
      "severity": "warning",
      "example": "80 character limit for code. Break at natural boundaries (after operators, before parameters). Use proper indentation for continuations. No limit for markdown/YAML.",
      "context": "80 character limit ensures readability in split-screen editors, code review tools, and terminals.",
      "keywords": ["line-length", "80-characters", "wrapping"],
      "tags": ["example", "line-length", "formatting", "correct"]
    },
    {
      "rule_id": "format-005-final-newline",
      "category": "formatting",
      "severity": "warning",
      "example": "All files end with newline. Configure in .editorconfig: insert_final_newline = true. VSCode: files.insertFinalNewline = true.",
      "context": "POSIX defines text file as ending with newline. Prevents issues with shell scripts and diff tools.",
      "keywords": ["final-newline", "EOF", "newline"],
      "tags": ["example", "final-newline", "formatting", "correct"]
    },
    {
      "rule_id": "format-006-trailing-whitespace",
      "category": "formatting",
      "severity": "warning",
      "example": "Trim trailing whitespace except in markdown. Configure in .editorconfig: trim_trailing_whitespace = true (false for .md). VSCode: files.trimTrailingWhitespace = true.",
      "context": "Trailing whitespace creates diff noise and wastes space. Markdown uses two trailing spaces for line breaks.",
      "keywords": ["trailing-whitespace", "trim", "whitespace"],
      "tags": ["example", "whitespace", "formatting", "correct"]
    }
  ],
  "typescript_rules": [
    {
      "rule_id": "ts-001-discriminated-unions",
      "category": "typescript",
      "severity": "blocking",
      "example": "Tagged unions with _tag field. Result<T,E> = {_tag:'ok',value:T} | {_tag:'error',error:E}. Exhaustive matching with switch on _tag. Type-safe constructors. Pattern matching helpers.",
      "context": "Discriminated unions enable type-safe pattern matching and ensure all cases are handled. TypeScript's equivalent of sum types.",
      "keywords": ["discriminated-union", "_tag", "pattern-matching", "exhaustive"],
      "tags": ["example", "discriminated-unions", "ADT", "correct"]
    },
    {
      "rule_id": "ts-002-branded-types",
      "category": "typescript",
      "severity": "warning",
      "example": "Branded types: type UserId = string & {readonly __brand: 'UserId'}. Smart constructor validates and returns Result. Unsafe constructor for trusted sources. Unwrap function extracts raw value.",
      "context": "Brands prevent mixing semantically different values. Zero runtime cost, compile-time safety.",
      "keywords": ["branded-types", "newtype", "smart-constructor", "validation"],
      "tags": ["example", "branded-types", "type-safety", "correct"]
    },
    {
      "rule_id": "ts-003-explicit-annotations",
      "category": "typescript",
      "severity": "warning",
      "example": "Explicit annotations on all function parameters and return types. Type inference OK for local variables. Annotations serve as documentation and catch errors at boundaries.",
      "context": "Explicit annotations make refactoring safer and improve IDE support. Essential for public APIs.",
      "keywords": ["type-annotation", "explicit-types", "function-signature"],
      "tags": ["example", "type-annotations", "documentation", "correct"]
    },
    {
      "rule_id": "ts-004-readonly-types",
      "category": "typescript",
      "severity": "blocking",
      "example": "Readonly types everywhere: Readonly<T> for objects, ReadonlyArray<T> for arrays. Use readonly modifier on properties. Enforces immutability at type level.",
      "context": "Readonly types prevent accidental mutations and make immutability guarantees explicit. Catches mutation bugs at compile time.",
      "keywords": ["readonly", "ReadonlyArray", "Readonly", "immutability"],
      "tags": ["example", "readonly", "immutability", "correct"]
    },
    {
      "rule_id": "ts-005-type-level-programming",
      "category": "typescript",
      "severity": "advisory",
      "example": "Type-level programming: mapped types for transformations, conditional types for logic, template literals for string types. Encode invariants in types rather than runtime checks.",
      "context": "Type-level programming catches errors at compile time and provides better IDE support. Balance complexity with readability.",
      "keywords": ["mapped-types", "conditional-types", "template-literals", "generics"],
      "tags": ["example", "type-level", "advanced-types", "correct"]
    }
  ]
}
