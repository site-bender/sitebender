# Studio (aka @sitebender/studio) — High-Level Overview

Memory anchor

- Canonical, machine-readable snapshot: docs/studio-overview.yaml
- If MD and YAML differ, YAML is authoritative for policy/guardrails and decision logs.
- Use the YAML to rehydrate assistant context after resets.

Studio is a Deno + TypeScript, progressive-enhancement-first web framework built from a suite of zero-dependency functional libraries. The system is architected to minimize developer cognitive load while enforcing architectural integrity and accessibility. Documentation is generated from code; tests are generated by proofs where feasible; and the data model is grounded in a single source of truth: a triple store.

## Core Principles and Constraints

- Platform/runtime
  - Deno + TypeScript only
  - Pure ESM modules
  - No bundling; rely on static analysis and tree-shaking
  - Node compatibility is not a goal

- Authoring and rendering
  - No React, no VDOM; plain JSX (use `class`, `for`, etc.)
  - Everything works without JavaScript; progressive enhancement layered on top

- Dependencies policy
  - Zero dependencies across libraries
  - Sole allowed exception: Arborist (Arborist) depends on the TypeScript compiler
  - Testing and server-side infra (e.g., distributed systems, DBs) may use deps as needed

- Governance and structure (Warden-enforced)
  - No barrel files, ever; direct tree imports only
  - No re-exports (exception: explicit function aliases like `includes` → `contains`)
  - One function per file; named functions; export on the same line
  - Underscore-folder privacy; strict boundaries; no escape hatches
  - Contracts and privacy rules are enforced; AIs must comply

- Accessibility
  - Accessibility is a first-class requirement
  - Axe is integrated for automated checks (warn mode initially; hard fail before production)
  - Components enforce semantic HTML, allowable attributes/descendants, and ARIA correctness

- Enforcement stack (execution order)
  - Steward (style/shape, deterministic autofixes) → deno fmt → Warden (governance/contracts)
  - Goal: normalize code shape first to reduce governance noise and stabilize downstream tools

## Data Model and Flow

- Single Source of Truth
  - The triple store is the single, sole source of truth for data (data-centric architecture)
  - Constraints and validation live in SHACL and/or OWL2 (e.g., regex facets for strict typing)
  - Application artifacts can be stored as JSON/YAML/TOML/Turtle; Turtle/SHACL model expresses canonical semantics

- Authoring → Runtime
  - JSX → IR (internal, not exposed outside Architect except in the Workshop)
  - IR → persisted artifacts (JSON/YAML/TOML/Turtle) for DB/triple store
  - Architect.render(JSON) → DOM (no VDOM)

## Architect Runtime — Current Implementation Snapshot

- Build pipeline (client/runtime)
  - `buildDomTree(parent)(config)(options)` creates elements, attaches behaviors, and appends children
  - Special cases
    - `Fragment` handled by `handleFragment`
    - `TextNode` handled by `appendTextNode`
    - `Hn` maps to `H{level}` via `setLevel`
  - Attributes and dataset
    - `addAttributes(elem)(attributes)`
    - `addDataAttributes(elem)(dataset)`

- Behavior attachment (DOM properties on elements)
  - Calculation
    - `addCalculation(elem)(calculation)`
    - Attaches: `elem.__sbCalculate(arg?, localValues?)` (async)
    - Reads input: `value` for `INPUT/SELECT/TEXTAREA/DATA`, else `innerHTML`
    - Composes operators: `composeOperators(Operand)`
    - Writes output back to `value` or `innerHTML`
    - Dispatches `InputEvent("input", { bubbles: true })`
    - Tracks:
      - `elem.dataset.calculation = JSON.stringify(calculation)`
      - `document.__sbCalculators: Set<elementId>`
      - `document.__sbCalculations[selector]: Set<elementId>`
  - Formatting
    - `addFormatter(elem)(fmt)`
    - Attaches: `elem.__sbFormat(arg?, localValues?)` (async)
    - Uses `formatter(fmtTag)` to produce an async function
    - Returns the formatted value (does not write back itself)
    - Tracks:
      - `elem.dataset.format = JSON.stringify(fmt)`
      - `document.__sbFormatters: Set<elementId>`
      - `document.__sbFormatted[selector]: Set<elementId>`
  - Validation
    - `addValidation(elem)(validation)`
    - Attaches: `elem.__sbValidate(arg, localValues?)` (async)
    - Lazily composes on first call: `composeValidator(Comparator|Logical|Operand)`
    - Returns `Either<Array<ArchitectError>, boolean>`; Right is normalized to boolean
    - (No document-level registry here yet)

- SSR and IR
  - Minimal SSR helpers exist for tests; IR can be embedded for debugging (`embedIr.ts`)
  - Hydration/reactivity specifics will be finalized later (no VDOM)

## Declarative Testing Strategy

**Testing is not separate from the application - it's part of the data model.**

Instead of bolted-on test infrastructure, testing becomes declarative JSX components that compile to data:

### Distribution Across Libraries

- **Agent**: IO interception, recording, replay, network simulation
- **Architect**: Mock response generation, scenario state, transformations
- **Auditor**: Contract verification, coverage analysis, invariant proofs
- **Custodian**: Stateful scenarios, time control, state machines
- **Envoy**: Mock observability, dashboards, drift detection
- **Warden**: Production safety, mock boundary enforcement
- **Sentinel**: Authentication/authorization mocking and policies
- **Formulator**: Dynamic mock expressions, conditional logic

All coordinated through Architect's `TestHarness` meta-component.

## Library Suite (Alphabetical)

- **Agent**  
  Distributed/hybrid data adapters (CRDTs, P2P, DID/VC, IPFS, Solid). Offline-first by default. **Now includes IO interception for testing.**

- **Arborist**  
  TypeScript/JSX parser and AST analyzer. The ONLY library with an external dependency (TypeScript compiler). Powers Envoy and Auditor with formal AST API.

- **Architect**  
  Reactive computation core and render pipeline. JSX → IR → serialized formats → HTML/composed functions. No VDOM; SSR/SSG; minimal hydration. **Now includes TestHarness orchestration for declarative testing.**

- **Auditor**  
  Formal verification and proof generation using Z3 theorem prover. Proves correctness mathematically, not just by example. **Now includes mock contract verification.**

- **Custodian**  
  State management that respects web fundamentals. URL-as-state, form-based mutations, idempotent operations. Works without JavaScript, enhances progressively. **Includes stateful test scenarios and time control.**

- **Envoy**  
  Documentation and observability intelligence system. Transforms codebases into living knowledge graphs. HATEOAS navigation, SPARQL queries, custom comment syntax (`//++`, `//--`, `//??`, `//!!`, `//>>`) with categories. **Now includes mock observability dashboards.**

- **Formulator**  
  Expression parser that compiles to/from Architect IR. Handles operator precedence, variables, functions. Enables formulas in data. Serializes beyond JSON (YAML/TOML/Turtle).

- **Operator**  
  Pure functional pub/sub system for event-driven architectures. Enables reactive communication between components without tight coupling.

- **Pagewright**  
  Accessible JSX components and DSL for semantic HTML, progressive enhancement, structured data. Enforces W3C/WHATWG standards at compile time with typed element wrappers.

- **Quarrier**  
  Generators, QuickCheck-style property testing utilities, shrinking algorithms, and sample triple generation for property-based testing.

- **Quartermaster**  
  Studio application generator CLI using declarative blueprints. Provisions app skeletons with import-map wiring and pre-wired Warden/Steward/axe tasks. Blueprint-driven scaffolding.

- **Sentinel**  
  Authentication, authorization, and security policies as declarative JSX. OAuth2, WebAuthn, DID authentication; Rbac/Abac; security policies stored as triples. **Includes mock authentication for testing.**

- **Steward**  
  Deterministic, non-configurable style/structure enforcer with safe autofixes. Runs before Warden to normalize code shape. Targets ≤ 3s repo-wide checks.

- **Toolsmith**  
  Pure FP primitives and combinators (monads, do-notation, mathematical laws). Foundation for all other libraries. Absolutely pure (IO isolated).

- **Warden**  
  Cryptographically enforced architectural governance. SHA-256 contracts, underscore privacy, import validation, graduated enforcement (pending→warn→block). AI-safe. **Now includes mock production safety.**

## Applications (Dogfooding)

- `/applications/mission-control` → mission-control  
  Envoy-generated docs with live examples and structured data.

- `/applications/the-workshop` → the-workshop  
  Interactive sandbox: JSX → IR → JSON/YAML/TOML/Turtle → DB → HTML; real-time compilation and visualization.

- `/applications/the-agency` → the-agency  
  Experimental integrations (IPFS/Solid/RDF/blockchain) orchestrated by Agent.

## Roadmap and Priorities (Consensus-Level)

1. Warden (highest priority)
   - Repo-wide enforcement; foolproof; stop AI-induced architectural drift
   - Policy: warn in PRs; block on main

2. Toolsmith (next highest)
   - Complete lifted functions; clean comments; enforce style guide; lock down
   - Used everywhere, so must be rock solid

3. Steward
   - Introduce deterministic style/shape enforcement; wire CI (PR warn, main block)
   - Target ≥ 90% safe autofix coverage on targeted rules; ≤ ~3s typical checks

4. Parallel independents (after Warden/Toolsmith/Steward are functional)
   - Quarrier (Quarrier) — generators/property testing helpers
   - Arborist (Arborist) — TS compiler based parser
   - Formulator (Formulator) — expression ↔ IR
   - Agent (Agent) — CRDT/DID/VC/IPFS/Solid
   - Quartermaster (App Generator) — blueprint-driven scaffolding and wiring

5. Dependent pair (build after the above are ready)
   - Auditor (Auditor) and Envoy

6. Pagewright and Architect
   - Already far along; continue development with awareness that they’re more complete than typical alpha

7. Monorepo wiring and cleanup (ASAP)
   - Import maps, pure ESM delivery
   - Remove/relocate stale or confusing docs to avoid misleading AIs

## Accessibility Policy

- Axe integrated in CI
  - Warn mode until component allowlists stabilize
  - Hard failure before production
- Component-level enforcement of semantics and ARIA rules

## Import Maps and Aliases (Dev vs Prod)

- Policy: Use import maps for stable aliases.
  - Dev: alias @sitebender/\* to local library src paths for short, stable imports and easy local iteration.
  - Prod: import the published library paths (no local src mapping).
- Example import (works in both modes):
  - import includes from "@sitebender/toolsmith/vanilla/array/includes/index.ts"
- Root dev config example (deno.dev.jsonc or root deno.jsonc "imports"):
  - "@sitebender/toolsmith/": "./libraries/toolsmith/src/"
  - "@sitebender/architect/": "./libraries/architect/src/"
- Per-package dev config (optional):
  - Each library can include a local deno.jsonc that maps @sitebender/\* to ../<lib>/src/ to allow -c package.jsonc execution.
- Running with dev config:
  - deno run -A --config deno.dev.jsonc libraries/steward/src/check/index.ts
  - or cd into the package and use deno task when the package has its own deno.jsonc

## Release and Versioning

- Semver by package (independent versions)
- Apps dogfood local libraries via import maps (no publish needed for local iteration)

## Acceptance Criteria (Alpha)

- Warden: enforced; pass on main
- Steward: repo-wide `steward:check` passes; ≥ 90% safe autofix on targeted rules; ≤ ~3s typical
- Quartermaster: generates mission-control and the-workshop skeletons (Pagewright-only and +Architect); correct import maps; Warden enforce passes; axe warn wired
- Playground: renders JSON-defined example without JS assumptions
- Docs app: serves Envoy-generated docs for key APIs
- Performance: validation ~< 5s repo-wide

## Acceptance Criteria (Production)

- Warden: block violations in CI and locally
- Axe: hard-fail with documented allowlists
- Privacy: no private boundary violations; no escape hatches
- Imports: no barrel files; direct tree imports; aliases allowed only as explicit function synonyms
- Docs: Envoy docs up-to-date with code; navigable HATEOAS graph
- Proofs/tests: coverage gate meets target; auditor-generated tests stable

## Decision Log (additions)

- Steward pre-enforcement
  - Decision: Introduce Steward as deterministic style/shape autofixer before Warden
  - Rationale: Normalize code surface to reduce governance noise and simplify downstream tools

- Quartermaster blueprints
  - Decision: Blueprint-driven app generator with import-map wiring
  - Rationale: Deterministic scaffolding, consistent CI tasks, easier GUI integration

## Scripts Reference (for Steward planning)

As reference for existing (temporary/mediocre) enforcement approaches, see:

- `scripts/enforceEnvoyStyle/`
- `scripts/enforceFP/`
- `scripts/enforceImports/`
- `scripts/enforceNoReactJunk/`

These provide prior art for style checks, import rules, and React-ism detection. Steward will supersede these with AST-based deterministic checks and safe autofixes, aligning with Studio’s strict style guide.

## Items Explicitly Deferred (to future RFCs)

- Hydration strategy and lifecycle details (attach/detach, scheduling, event delegation)
- Reactivity model specifics (signals/cells/effects, cleanup guarantees)
- JSX transform pipeline details (TS compiler hooks, custom createElement/Fragment)
- Final IR v0 schema and serialization rules
- Accessibility allowlists finalization and gating mode transition

## Future Vision

### Distributed Triple Store with IPFS+IPLD

- Content-addressed triples with natural deduplication
- P2P distribution by default, no single point of failure
- Event sourcing pattern for perfect state reconstruction
- CRDT-like conflict resolution for distributed updates
- Debugging sessions shareable via IPFS hashes

### Computation Marketplace

Since behaviors are data (JSON/YAML/Turtle), computations become tradeable:

- Cryptographically verified via Auditor proofs
- Content-addressed via IPFS
- Semantically described via SHACL/OWL2
- Automatic compatibility checking
- Micropayments for usage
- See `libraries/agent/docs/computation-marketplace.md` for details

### Formal Verification with Z3

Transform Auditor from test generator to mathematical proof system:

- Prove properties for ALL inputs, not just test cases
- Generate counterexamples for failures
- Verify entire applications mathematically
- IR as formal specification language
- See `libraries/auditor/docs/z3-formal-verification.md` for details

### Additional Innovations

- **Neural search**: Embed triples in vector space for semantic search
- **GUN-inspired CRDTs**: Pure functional version of GUN.js algorithm
- **DIDs as VCs**: Every triple as a verifiable credential
- **Blockchain witness**: Periodic anchoring for immutable history
- **Capabilities versioning**: Version capabilities not IR structure
- **AST extensibility**: Unknown nodes preserved like unknown HTML

## Bottom Line

- Data-centric: triple store is the truth; JSON is the likely render input artifact
- Architect renders from JSON with no VDOM; behaviors are attached as DOM properties
- Steward normalizes style/shape; Warden governs privacy, imports, and contracts
- Accessibility and semantics are mandatory; ergonomics without sacrificing correctness
- Documentation and tests are generated from code and models where possible
- **The future**: Distributed, formally verified, marketplace-enabled computation
