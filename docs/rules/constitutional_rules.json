{
  "result": {
    "points": [
      {
        "id": "144ca584-a472-48e7-ad53-0fbf1a753bad",
        "payload": {
          "document": "NO RE-EXPORTS except function aliases (e.g., aliasing 'includes' to 'contains')",
          "metadata": {
            "rule_id": "IMPORT_NO_REEXPORT_001",
            "category": "constitutional",
            "reason": "Re-exports obscure the true source, break tree shaking, and create dependency tangles",
            "consequences": "Bundle bloat, circular dependencies, unclear import origins",
            "philosophy": "Transparent dependencies - know exactly where code comes from",
            "examples": {
              "wrong": "export * from './utils'",
              "acceptable": "export { default as contains } from '../includes/index.ts'"
            },
            "exception": "Function aliases for better naming only",
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "14d023d2-932f-4d3d-9f1f-67aedf8a6d11",
        "payload": {
          "document": "Co-locate all related files: CSS with components, API calls with modules that use them, scripts with components they enhance. Organize by feature, not by file type",
          "metadata": {
            "rule_id": "COLOCATION_OVER_TYPE_001",
            "category": "constitutional",
            "reason": "Things that change together should live together. Delete safety - remove a feature and everything goes with it",
            "consequences": "Type-based folders (styles/, api/, utils/) create hidden dependencies and orphan code",
            "philosophy": "Feature-based organization over type-based organization",
            "examples": {
              "correct": "UserCard/index.tsx, UserCard/index.css, UserCard/index.ts (enhancement script)",
              "wrong": "components/UserCard.tsx, styles/UserCard.css, scripts/userCard.js"
            },
            "anti_patterns": [
              "styles/ folder (except global)",
              "api/ folder",
              "utils/ folder",
              "scripts/ folder"
            ],
            "applies_to": [
              "*"
            ]
          }
        }
      },
      {
        "id": "1645984c-7fa8-43f6-a828-84cd66d32a91",
        "payload": {
          "document": "ANTI-PATTERN: Using classes and OOP patterns",
          "metadata": {
            "rule_id": "ANTI_OOP_001",
            "category": "constitutional",
            "reason": "OOP is the opposite of functional programming. Classes create stateful nightmares",
            "consequences": "Classes = mutable state = bugs = unmaintainable code",
            "philosophy": "Pure functions only. Composition over inheritance",
            "examples": {
              "anti_pattern": "class UserService { private users = []; addUser() { this.users.push() } }",
              "correct": "Module with pure functions that take state as parameters and return new state"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "1733792a-740f-465c-aace-d15da318d598",
        "payload": {
          "document": "ANTI-PATTERN: Organizing by file type (utilities/, styles/, api/ folders) instead of by feature",
          "metadata": {
            "rule_id": "ANTI_TYPE_ORGANIZATION_001",
            "category": "constitutional",
            "reason": "Type-based organization breaks co-location and creates hidden dependencies",
            "consequences": "Moving or deleting features becomes nightmare - related files scattered across type folders",
            "philosophy": "Feature cohesion over type segregation",
            "examples": {
              "anti_pattern": "styles/UserCard.css, components/UserCard.tsx, utils/userHelpers.ts",
              "correct": "UserCard/index.tsx, UserCard/index.css, UserCard/index.ts"
            },
            "applies_to": [
              "*"
            ]
          }
        }
      },
      {
        "id": "23f2a76e-0b2b-41f0-9554-5ece9665e4b6",
        "payload": {
          "document": "NO BARREL FILES. EVER. No index.ts that re-exports other modules. Use aliases for shorter import paths, not re-exports",
          "metadata": {
            "rule_id": "IMPORT_NO_BARREL_001",
            "category": "constitutional",
            "reason": "Barrel files destroy tree shaking, create circular dependency nightmares, and obscure import paths. Aliases solve the same problem without the downsides",
            "consequences": "Barrel files bloat bundles, cause circular references, and make debugging imports hell",
            "philosophy": "Explicit imports with aliases, not hidden re-exports",
            "examples": {
              "wrong": "export { Button } from './Button'; export { Card } from './Card'",
              "right": "import Button from '@sitebender/pagewright/interact/buttons/Button/index.tsx'"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "479a5262-9118-4a9f-a547-29ae5251ea9e",
        "payload": {
          "document": "NEVER use Web Components - they require JavaScript to work",
          "metadata": {
            "rule_id": "FP_NO_WEB_COMPONENTS_001",
            "category": "constitutional",
            "reason": "Web Components violate progressive enhancement - they're dead without JS. Shadow DOM is a catastrophe",
            "consequences": "Users without JS get NOTHING. Violates our core philosophy",
            "philosophy": "HTML should work without JavaScript",
            "alternatives": [
              "Server-side rendering",
              "Progressive enhancement",
              "Standard HTML elements"
            ],
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx",
              ".html"
            ]
          }
        }
      },
      {
        "id": "54cbd40a-0afa-46d6-8637-de8182c84dc5",
        "payload": {
          "document": "ONE function per file, NO EXCEPTIONS except functions part of currying. Helper functions go in nested folders at LOWEST COMMON ANCESTOR",
          "metadata": {
            "rule_id": "FUNC_ONE_PER_FILE_001",
            "category": "constitutional",
            "reason": "Extreme modularity. Clear dependencies. Automatic cleanup when deleting features",
            "consequences": "Multiple functions per file create hidden dependencies and leave orphan code",
            "philosophy": "Delete safety - remove a feature and all its helpers disappear with it",
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "664d5620-bc17-4e91-91d5-15824b067ed1",
        "payload": {
          "document": "All functions exported as DEFAULT on the SAME LINE as declaration",
          "metadata": {
            "rule_id": "FUNC_EXPORT_001",
            "category": "constitutional",
            "reason": "Single clear export point. No hunting for export statements",
            "consequences": "Separate export statements create confusion about what's exported",
            "philosophy": "Explicit and immediate - see the export at the function definition",
            "examples": {
              "correct": "export default function calculateTotal(items: Array<Item>): number {",
              "wrong": "function calculateTotal(items: Array<Item>): number { ... } export default calculateTotal"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "6d576540-d552-483f-8a1b-ade6e01012f9",
        "payload": {
          "document": "Use pubsub (Operator library) for complete decoupling between modules. Modules should be independently deletable and moveable",
          "metadata": {
            "rule_id": "PUBSUB_DECOUPLING_001",
            "category": "constitutional",
            "reason": "Complete module independence. Move or delete modules without breaking dependencies",
            "consequences": "Direct coupling creates brittle dependencies that break when refactoring",
            "philosophy": "Modules communicate via events, not direct calls",
            "examples": {
              "correct": "emit('user.created', userData); subscribe('user.created', handleNewUser)",
              "wrong": "userModule.handleNewUser(userData) // direct coupling"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "8e735570-8450-4e3b-ac80-fa94da69dcbd",
        "payload": {
          "document": "ANTI-PATTERN: Multiple functions in one file",
          "metadata": {
            "rule_id": "ANTI_MULTIPLE_FUNCTIONS_001",
            "category": "constitutional",
            "reason": "Violates modularity, creates hidden dependencies, leaves orphan code when refactoring",
            "consequences": "Can't delete individual functions cleanly. Related code scattered in same file",
            "philosophy": "One function = one file = one purpose",
            "examples": {
              "anti_pattern": "utils.ts with add(), subtract(), multiply() all in one file",
              "correct": "add/index.ts, subtract/index.ts, multiply/index.ts in separate folders"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "9284b64f-01c7-4a1a-8431-3b00ebe875a4",
        "payload": {
          "document": "Single-use types can live in the file that uses them, preferably BELOW the function/component code (except Props above component)",
          "metadata": {
            "rule_id": "TYPE_PLACEMENT_001",
            "category": "constitutional",
            "reason": "Keeps function/component at top of file for immediate visibility. Co-location for single-use types",
            "consequences": "Scrolling past type definitions to find the actual code",
            "philosophy": "Important code first, supporting types below",
            "examples": {
              "correct": "export default function process(data: Data): Result { ... } type Data = { id: string }",
              "exception": "Props types go ABOVE components for visibility"
            },
            "applies_to": [
              ".ts",
              ".tsx"
            ]
          }
        }
      },
      {
        "id": "93848890-e8d0-489a-a11c-583992020318",
        "payload": {
          "document": "ALL CODE FILES ARE CALLED index.ts(x) - Function/component names go on the FOLDER, not the file. File is ALWAYS index.ts(x) in that folder. This is a CONSTITUTIONAL RULE. No exceptions. mod.ts is the only exception (and it contains only Envoy comments, no code).",
          "metadata": {
            "rule_id": "FILE_NAMING_INDEX_001",
            "category": "constitutional",
            "reason": "Consistent file naming eliminates cognitive load and prevents naming conflicts",
            "consequences": "Inconsistent file naming creates navigation nightmares and violates the folder-as-namespace principle",
            "philosophy": "One file per folder = one purpose per folder = clear mental model",
            "examples": {
              "correct": "processData/index.ts containing function processData",
              "wrong": "processData.ts or processData/processData.ts"
            },
            "applies_to": [
              "ALL CODE FILES"
            ],
            "severity": 10
          }
        }
      },
      {
        "id": "b207700f-a519-45e3-b514-7ee0725df155",
        "payload": {
          "document": "ANTI-PATTERN: Making assumptions instead of asking for clarification",
          "metadata": {
            "rule_id": "ANTI_ASSUMPTION_001",
            "category": "constitutional",
            "reason": "Assumptions create messes that take weeks to fix",
            "consequences": "Wrong assumptions = broken code = wasted time = lost trust",
            "philosophy": "Better to ask 10 questions than make 1 wrong assumption",
            "examples": {
              "anti_pattern": "Assuming user wants X and implementing without asking",
              "correct": "Ask for clarification when requirements are unclear"
            },
            "severity": 10,
            "alternative": "ASK when uncertain. Always",
            "applies_to": [
              "*"
            ]
          }
        }
      },
      {
        "id": "d52ec5bb-b75e-4f68-8d72-495c9b523d33",
        "payload": {
          "document": "Function name ALWAYS matches folder name (camelCase). File is ALWAYS index.ts",
          "metadata": {
            "rule_id": "FUNC_FILE_STRUCTURE_001",
            "category": "constitutional",
            "reason": "Consistent structure reduces cognitive load. Always know where to find a function",
            "consequences": "Inconsistent naming creates navigation nightmares",
            "philosophy": "Absolute consistency eliminates decision fatigue",
            "examples": {
              "correct": "processData/index.ts containing function processData",
              "wrong": "process-data.ts or processData/processData.ts"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "d58ded34-9724-4c26-9631-3a72a9d92fc5",
        "payload": {
          "document": "ANTI-PATTERN: Non-curried functions with multiple parameters",
          "metadata": {
            "rule_id": "ANTI_NON_CURRIED_001",
            "category": "constitutional",
            "reason": "All Sitebender functions must be curried for composition and partial application",
            "consequences": "Multi-parameter functions can't be composed or partially applied",
            "philosophy": "Functions are building blocks - they must be composable",
            "examples": {
              "anti_pattern": "function add(a: number, b: number): number { return a + b }",
              "correct": "function add(augend: number) { return function addToAugend(addend: number): number { return augend + addend } }"
            },
            "severity": 9,
            "alternative": "Curry all Sitebender functions",
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "e4882916-d587-4e5c-900e-aa304c11b129",
        "payload": {
          "document": "Functions and components placed at LOWEST COMMON ANCESTOR - the lowest node where all consumers branch",
          "metadata": {
            "rule_id": "LOWEST_COMMON_ANCESTOR_001",
            "category": "constitutional",
            "reason": "Automatic cleanup - delete a feature and all its helpers go with it. No orphan code. Clear ownership",
            "consequences": "Functions at wrong level create hidden dependencies and accumulate as tech debt",
            "philosophy": "Modular architecture - things that change together live together",
            "examples": {
              "correct": "userAuth/_hashPassword/ (used by login AND register), login/_validateCredentials/ (only login uses)",
              "wrong": "utils/hashPassword/ (too high if only userAuth uses it)"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "f8695c47-a417-493f-a3d9-3557cf87608e",
        "payload": {
          "document": "All functions must be curried: function add(augend: number) { return function addToAugend(addend: number): number { return augend + addend } }",
          "metadata": {
            "rule_id": "PATTERN_CURRYING_001",
            "category": "constitutional",
            "priority": 10,
            "reason": "Currying enables partial application and composition, inner function name captures outer parameter",
            "consequences": "Non-curried functions can't be easily composed or partially applied",
            "philosophy": "All functions should be composable building blocks",
            "examples": {
              "wrong": "const add = (a: number, b: number): number => a + b",
              "correct": "function add(augend: number) { return function addToAugend(addend: number): number { return augend + addend } }"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "fb6c0432-ca3d-4763-a920-e760a5ac9455",
        "payload": {
          "document": "Folder hierarchy PRECISELY matches code hierarchy. Embrace the folders!",
          "metadata": {
            "rule_id": "FILE_HIERARCHY_001",
            "category": "constitutional",
            "priority": 9,
            "reason": "See entire app structure at a glance. Collapse what you don't care about. Related files stay together",
            "consequences": "Flat structures or multi-function files create navigation nightmares",
            "philosophy": "Folders are free. Use them liberally. They're not going extinct",
            "examples": {
              "correct": "processUser/index.ts, processUser/_validateUser/index.ts, processUser/_normalizeEmail/index.ts",
              "wrong": "utils.ts with 20 functions inside"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "fc59579f-9a2f-4cb8-804f-376b65f9395f",
        "payload": {
          "document": "ALWAYS import AS DEFAULT directly from the function or component file. Use @sitebender aliases, never relative paths",
          "metadata": {
            "rule_id": "IMPORT_DEFAULT_DIRECT_001",
            "category": "constitutional",
            "priority": 9,
            "reason": "Clearest and simplest. Shows exact dependency. Enables vigorous tree shaking. Aliases prevent breakage when moving modules",
            "consequences": "Named imports and relative paths create ambiguity, bloat, and breakage when refactoring",
            "philosophy": "Explicit direct dependencies with move-safe aliases",
            "examples": {
              "correct": "import sum from '@sitebender/toolsmith/vanilla/array/sum/index.ts'",
              "wrong": "import { sum } from '@sitebender/toolsmith'; import sum from '../utils/sum'"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      }
    ],
    "next_page_offset": null
  },
  "status": "ok",
  "time": 0.001374959
}
