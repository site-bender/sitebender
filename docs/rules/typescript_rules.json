{
  "result": {
    "points": [
      {
        "id": "03623e89-17fd-4bbf-93c7-3f3b8bd4b74a",
        "payload": {
          "document": "TS_GEN_014 - Generic Constraints: Generic constraints ensure type parameters meet specific requirements, providing compile-time safety while maintaining flexibility. Use extends clauses to constrain type parameters and ensure they have required properties or behaviors. Example: type HasId = { id: string; }; function updateEntity<T extends HasId>(entity: Readonly<T>) { return function updateEntityWithEntity(updates: Readonly<Partial<Omit<T, 'id'>>>): Readonly<T> { return { ...entity, ...updates }; } } function processStringifiable<T extends { toString(): string }>(value: T) { return function processStringifiableValue(): string { return `Processed: ${value.toString()}`; } }",
          "metadata": {
            "rule_id": "TS_GEN_014",
            "category": "generics",
            "priority": 8,
            "reason": "Generic constraints ensure type parameters meet specific requirements, providing compile-time safety while maintaining flexibility",
            "consequences": "Unconstrained generics allow invalid type combinations and reduce type safety in generic functions",
            "philosophy": "Generic Constraints - use extends clauses to constrain type parameters and ensure they have required properties or behaviors",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "warning"
          }
        }
      },
      {
        "id": "05d0f856-b7b4-4bb9-b239-025268539f0e",
        "payload": {
          "document": "TS_FUN_012 - Function Composition Types: Proper function composition types enable type-safe pipeline operations and make complex transformations more readable and maintainable. Design types to support currying, piping, and composition patterns for functional programming. Example: type Unary<A, B> = (a: A) => B; type Binary<A, B, C> = (a: A) => (b: B) => C; function pipe<A, B, C>(f: Unary<A, B>): (g: Unary<B, C>) => Unary<A, C> { return function pipeWithF(g: Unary<B, C>): Unary<A, C> { return function pipedFunction(a: A): C { return g(f(a)); } } }",
          "metadata": {
            "rule_id": "TS_FUN_012",
            "category": "function-composition",
            "priority": 8,
            "reason": "Proper function composition types enable type-safe pipeline operations and make complex transformations more readable and maintainable",
            "consequences": "Improper composition types lead to type errors and make it difficult to build reusable, composable functions",
            "philosophy": "Function Composition Types - design types to support currying, piping, and composition patterns for functional programming",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "warning"
          }
        }
      },
      {
        "id": "20812365-e519-4fc2-9e7d-d2f306e54e8e",
        "payload": {
          "document": "TS_IMM_004 - Readonly Types for Immutability: Readonly types enforce immutability at the type level, preventing accidental mutations and supporting functional programming patterns. Use Readonly<T> and ReadonlyArray<T> to encode immutability constraints in the type system. Example: function updateUser(user: Readonly<User>, updates: Readonly<Partial<User>>): Readonly<User> { return { ...user, ...updates }; } function mapUsers(users: ReadonlyArray<User>): ReadonlyArray<ProcessedUser> { return users.map(processUser); }",
          "metadata": {
            "rule_id": "TS_IMM_004",
            "category": "immutability",
            "priority": 9,
            "reason": "Readonly types enforce immutability at the type level, preventing accidental mutations and supporting functional programming patterns",
            "consequences": "Mutable types allow accidental mutations that break immutability guarantees and cause hard-to-debug side effects",
            "philosophy": "Readonly Types for Immutability - use Readonly<T> and ReadonlyArray<T> to encode immutability constraints in the type system",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "blocking"
          }
        }
      },
      {
        "id": "25777683-9b29-4ee2-b3c7-ec68ed557300",
        "payload": {
          "document": "TS_GEN_014 - Generic Constraints: Generic constraints ensure type parameters meet specific requirements, providing compile-time safety while maintaining flexibility. Use extends clauses to constrain type parameters and ensure they have required properties or behaviors. Example: interface HasId { id: string; } function updateEntity<T extends HasId>(entity: Readonly<T>, updates: Readonly<Partial<Omit<T, 'id'>>>): Readonly<T> { return { ...entity, ...updates }; } function processStringifiable<T extends { toString(): string }>(value: T): string { return `Processed: ${value.toString()}`; }",
          "metadata": {
            "rule_id": "TS_GEN_014",
            "category": "generics",
            "priority": 8,
            "reason": "Generic constraints ensure type parameters meet specific requirements, providing compile-time safety while maintaining flexibility",
            "consequences": "Unconstrained generics allow invalid type combinations and reduce type safety in generic functions",
            "philosophy": "Generic Constraints - use extends clauses to constrain type parameters and ensure they have required properties or behaviors",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "warning"
          }
        }
      },
      {
        "id": "2e532697-9cb9-4797-80e9-f9aa338a62d7",
        "payload": {
          "document": "TS_BRT_009 - Smart Constructor Pattern: Smart constructors validate input and return Result types, ensuring branded types are always valid and providing clear error handling. Validate input and return Result<BrandedType, Error> to ensure branded types are always valid. Example: function userId(str: string): Result<UserId, ValidationError> { if (isNotEmpty(str) && str.length <= 50 && /^[a-zA-Z0-9_-]+$/.test(str)) { return success(str as UserId); } return failure({ _tag: 'ValidationError', field: 'userId', message: 'UserId must be 1-50 alphanumeric characters' }); }",
          "metadata": {
            "rule_id": "TS_BRT_009",
            "category": "brand-types",
            "priority": 8,
            "reason": "Smart constructors validate input and return Result types, ensuring branded types are always valid and providing clear error handling",
            "consequences": "Direct casting to branded types skips validation and allows invalid values to be treated as valid",
            "philosophy": "Smart Constructor Pattern - validate input and return Result<BrandedType, Error> to ensure branded types are always valid",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "warning"
          }
        }
      },
      {
        "id": "47476b9e-e16d-48f2-8f2c-ed9cb675e5c8",
        "payload": {
          "document": "TS_ADV_005 - Type-Level Programming: Type-level programming encodes constraints and relationships in the type system, providing compile-time guarantees and reducing runtime errors. Leverage mapped types, conditional types, and template literals to encode constraints and computations in the type system. Example: type NonEmptyArray<T> = readonly [T, ...T[]]; type EventName<T extends string> = `on${Capitalize<T>}`; type RequiredKeys<T> = { [K in keyof T]-?: {} extends Pick<T, K> ? never : K; }[keyof T];",
          "metadata": {
            "rule_id": "TS_ADV_005",
            "category": "type-level-programming",
            "priority": 8,
            "reason": "Type-level programming encodes constraints and relationships in the type system, providing compile-time guarantees and reducing runtime errors",
            "consequences": "Runtime-only constraints allow invalid states to compile and fail at runtime, reducing system reliability",
            "philosophy": "Type-Level Programming - leverage mapped types, conditional types, and template literals to encode constraints and computations in the type system",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "warning"
          }
        }
      },
      {
        "id": "50b8d689-f1cb-4c9c-8a7f-a21abb2dc0bc",
        "payload": {
          "document": "TS_UNK_008 - Unknown Type Alternatives: Unknown type requires explicit type checking before use, providing safety for truly unknown data while maintaining type system benefits. Use unknown for untrusted data and require type guards before accessing properties. Example: function isUser(value: unknown): value is User { return typeof value === 'object' && value !== null && 'id' in value && 'name' in value; } function processUnknownData(data: unknown): Result<User, ValidationError> { return isUser(data) ? success(data) : failure({ _tag: 'ValidationError', message: 'Not a valid user' }); }",
          "metadata": {
            "rule_id": "TS_UNK_008",
            "category": "type-safety",
            "priority": 9,
            "reason": "Unknown type requires explicit type checking before use, providing safety for truly unknown data while maintaining type system benefits",
            "consequences": "Using any or skipping type validation on unknown data leads to runtime errors and eliminates type safety",
            "philosophy": "Unknown Type Alternatives - use unknown for untrusted data and require type guards before accessing properties",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "blocking"
          }
        }
      },
      {
        "id": "5534f36a-8df4-441d-90a7-ab4cdf2d41c6",
        "payload": {
          "document": "TS_ADT_001 - Discriminated Unions for Safe Variants: Discriminated unions provide type-safe variant types with exhaustive pattern matching, eliminating null/undefined errors and enabling robust error handling. Use tagged unions with _tag field to enable exhaustive pattern matching and type-safe handling of variant types. Example: type Result<T, E> = | { _tag: \"success\"; value: T } | { _tag: \"failure\"; error: E }; function handleResult<T, E>(result: Result<T, E>): string { switch (result._tag) { case \"success\": return `Success: ${result.value}`; case \"failure\": return `Error: ${result.error}`; } }",
          "metadata": {
            "rule_id": "TS_ADT_001",
            "category": "algebraic-data-types",
            "priority": 10,
            "reason": "Discriminated unions provide type-safe variant types with exhaustive pattern matching, eliminating null/undefined errors and enabling robust error handling",
            "consequences": "Using null/undefined or boolean flags leads to runtime errors, non-exhaustive handling, and loss of type safety",
            "philosophy": "Discriminated Unions for Safe Variants - tagged unions with _tag field enable exhaustive pattern matching and type-safe handling of variant types",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "blocking"
          }
        }
      },
      {
        "id": "5f5f6474-c0f5-4321-a332-739f5503720f",
        "payload": {
          "document": "TS_ERR_013 - Error Type Design: Proper error type design with discriminated unions provides type-safe error handling without exceptions and clear error categorization. Use discriminated unions for error types with specific error categories and structured error information. Example: type ValidationError = { _tag: 'ValidationError'; field: string; message: string; }; type NetworkError = { _tag: 'NetworkError'; status: number; message: string; }; type AppError = ValidationError | NetworkError; function handleError(error: AppError): string { switch (error._tag) { case 'ValidationError': return `Validation failed for ${error.field}: ${error.message}`; case 'NetworkError': return `Network error ${error.status}: ${error.message}`; } }",
          "metadata": {
            "rule_id": "TS_ERR_013",
            "category": "error-handling",
            "priority": 9,
            "reason": "Proper error type design with discriminated unions provides type-safe error handling without exceptions and clear error categorization",
            "consequences": "Using exceptions or untyped errors leads to unhandled errors, unclear error contracts, and runtime crashes",
            "philosophy": "Error Type Design - use discriminated unions for error types with specific error categories and structured error information",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "blocking"
          }
        }
      },
      {
        "id": "8f6ecad2-e3fc-4ba9-aa5f-0a2679d88966",
        "payload": {
          "document": "TS_ARR_006 - Array<T> Syntax Consistency: Array<T> syntax is more explicit and consistent with generic type patterns, improving readability especially for complex nested types. Use Array<T> and ReadonlyArray<T> for consistency with generic patterns and clarity with complex types. Example: function processUsers(users: ReadonlyArray<User>, processors: ReadonlyArray<(user: User) => ProcessedUser>): ReadonlyArray<ProcessedUser> { return users.map(processors[0]); }",
          "metadata": {
            "rule_id": "TS_ARR_006",
            "category": "array-syntax",
            "priority": 7,
            "reason": "Array<T> syntax is more explicit and consistent with generic type patterns, improving readability especially for complex nested types",
            "consequences": "T[] syntax becomes unclear with complex types and doesn't consistently follow generic type conventions",
            "philosophy": "Array<T> Syntax Consistency - use Array<T> and ReadonlyArray<T> for consistency with generic patterns and clarity with complex types",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "advisory"
          }
        }
      },
      {
        "id": "9f7f16c6-0e4a-4232-987e-d342ae81b193",
        "payload": {
          "document": "TS_TYP_003 - Explicit Type Annotations: Explicit type annotations provide clear contracts, improve code readability, and catch type errors early in development. Always annotate function parameters and return types to create clear, self-documenting contracts. Example: function processUser(user: Readonly<User>, options: Readonly<ProcessOptions>): Result<ProcessedUser, ProcessError> { return processUserWithOptions(user, options); }",
          "metadata": {
            "rule_id": "TS_TYP_003",
            "category": "type-safety",
            "priority": 9,
            "reason": "Explicit type annotations provide clear contracts, improve code readability, and catch type errors early in development",
            "consequences": "Relying on type inference for public APIs creates unclear contracts and makes refactoring dangerous",
            "philosophy": "Explicit Type Annotations - always annotate function parameters and return types to create clear, self-documenting contracts",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "blocking"
          }
        }
      },
      {
        "id": "ad617790-5f86-4bb1-a5b2-6b1e6ddff127",
        "payload": {
          "document": "TS_BRT_011 - Unwrap Function Pattern: Unwrap functions provide a clear, named way to extract raw values from branded types for external APIs and serialization. Provide named unwrap functions to make extraction of raw values explicit and searchable. Example: function unwrapUserId(id: UserId): string { return id as string; } // Usage: Passing to external API const response = await fetch(`/api/users/${unwrapUserId(userId)}`); const dbQuery = 'SELECT * FROM users WHERE id = ?'; const result = await db.query(dbQuery, [unwrapUserId(userId)]);",
          "metadata": {
            "rule_id": "TS_BRT_011",
            "category": "brand-types",
            "priority": 7,
            "reason": "Unwrap functions provide a clear, named way to extract raw values from branded types for external APIs and serialization",
            "consequences": "Direct casting makes it unclear when and why branded types are being converted back to raw values",
            "philosophy": "Unwrap Function Pattern - provide named unwrap functions to make extraction of raw values explicit and searchable",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "advisory"
          }
        }
      },
      {
        "id": "b98b3b4c-3964-47c5-a5de-a737a7b46b0d",
        "payload": {
          "document": "Rule TS_UNK_008: Toolsmith Type Usage - NEVER use TypeScript's built-in unknown type - it is prohibited. Always use Toolsmith's PrimitiveValue, Serializable, Value, or Unknown types instead which provide better semantic meaning and type safety. We know what our types are, so use the appropriate Toolsmith type. Priority: 10. Applies to .ts, .tsx files.",
          "metadata": {
            "rule_id": "TS_UNK_008",
            "category": "type-safety",
            "priority": 10,
            "reason": "NEVER use TypeScript's built-in unknown type - it is prohibited. Always use Toolsmith's PrimitiveValue, Serializable, Value, or Unknown types instead which provide better semantic meaning and type safety",
            "consequences": "Using unknown violates type safety principles, reduces code clarity, and conflicts with our type system design that knows what types we're working with",
            "philosophy": "Toolsmith Type Usage - TypeScript has limited basic types, and the Toolsmith types provide better semantic meaning. We know what our types are, so use PrimitiveValue, Serializable, Value, or Unknown from Toolsmith",
            "examples": {
              "correct": "import { Value, Serializable, PrimitiveValue, Unknown } from '@sitebender/toolsmith';\n\nfunction isUser(value: Value): value is User {\n  return typeof value === 'object' &&\n    value !== null &&\n    'id' in value &&\n    'name' in value;\n}\n\nfunction processUnknownData(data: Unknown): Result<User, ValidationError> {\n  return isUser(data) \n    ? success(data)\n    : failure({ _tag: 'ValidationError', message: 'Not a valid user' });\n}\n\nfunction handlePrimitive(value: PrimitiveValue): string {\n  return String(value);\n}\n\nfunction serializeData(data: Serializable): string {\n  return JSON.stringify(data);\n}",
              "anti_pattern": "function processUnknownData(data: unknown): User {\n  // PROHIBITED: Never use TypeScript's unknown type\n  return data as User;\n}\n\nfunction handleValue(value: unknown): string {\n  // PROHIBITED: unknown type not allowed\n  return String(value);\n}"
            },
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "blocking"
          }
        }
      },
      {
        "id": "c83379af-01f8-40e6-8df7-f70b138110d7",
        "payload": {
          "document": "TS_ANY_007 - Any Type Prohibition: The any type completely disables TypeScript's type checking, eliminating the benefits of static typing and making code unsafe. Never use any; use unknown for truly unknown types and proper type definitions for known shapes. Example: function processApiResponse(response: unknown): Result<ProcessedData, ApiError> { if (isApiResponse(response)) { return success(processValidResponse(response)); } return failure({ _tag: 'ApiError', message: 'Invalid response' }); }",
          "metadata": {
            "rule_id": "TS_ANY_007",
            "category": "type-safety",
            "priority": 10,
            "reason": "The any type completely disables TypeScript's type checking, eliminating the benefits of static typing and making code unsafe",
            "consequences": "Using any allows runtime errors that TypeScript could prevent and eliminates intellisense and refactoring safety",
            "philosophy": "Any Type Prohibition - never use any; use unknown for truly unknown types and proper type definitions for known shapes",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "blocking"
          }
        }
      },
      {
        "id": "cfab30e9-7608-49a1-8305-969a6f3ae45a",
        "payload": {
          "document": "TS_BRT_002 - Branded Types with __brand: Branded types prevent mixing semantically different values that share the same structural type, providing compile-time safety without runtime cost. Use intersection types with unique brands to create nominal typing for domain concepts while maintaining zero runtime overhead. Example: type UserId = string & { readonly __brand: 'UserId' }; type Email = string & { readonly __brand: 'Email' }; function getUser(id: UserId): User { return findUserById(id); }",
          "metadata": {
            "rule_id": "TS_BRT_002",
            "category": "brand-types",
            "priority": 9,
            "reason": "Branded types prevent mixing semantically different values that share the same structural type, providing compile-time safety without runtime cost",
            "consequences": "Using raw primitives allows accidental mixing of different domain concepts, leading to semantic errors that pass type checking",
            "philosophy": "Branded Types with __brand - intersection types with unique brands create nominal typing for domain concepts while maintaining zero runtime overhead",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "blocking"
          }
        }
      },
      {
        "id": "d46e9742-aec2-45e7-b000-cb726a9071a6",
        "payload": {
          "document": "TS_NOM_015 - Nominal Typing Support: Nominal typing support through branded types and proper type design creates stronger type safety and clearer domain modeling. Combine branded types, smart constructors, and proper abstractions to achieve nominal typing benefits in TypeScript's structural system. Example: type UserId = string & { readonly __brand: 'UserId' }; type PostId = string & { readonly __brand: 'PostId' }; type CommentId = string & { readonly __brand: 'CommentId' }; // These are now nominally different despite same structure function getUser(id: UserId): Promise<User> { ... } function getPost(id: PostId): Promise<Post> { ... } function getComment(id: CommentId): Promise<Comment> { ... }",
          "metadata": {
            "rule_id": "TS_NOM_015",
            "category": "nominal-typing",
            "priority": 8,
            "reason": "Nominal typing support through branded types and proper type design creates stronger type safety and clearer domain modeling",
            "consequences": "Relying only on structural typing allows semantically different types with same structure to be used interchangeably",
            "philosophy": "Nominal Typing Support - combine branded types, smart constructors, and proper abstractions to achieve nominal typing benefits in TypeScript's structural system",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "warning"
          }
        }
      },
      {
        "id": "dc795397-6554-4866-a7a7-612ae17ba461",
        "payload": {
          "document": "TS_TYPE_INTERFACE_001 - Use type, Never interface: Always use type aliases, never use interface keyword. Interfaces are mutable, support declaration merging, and are designed for OOP patterns with classes. Types are immutable, sealed, and align with functional programming principles. Example correct: type User = { readonly id: string; readonly name: string; }; type ApiResponse<T> = { readonly data: T; readonly status: number; }. Example wrong: interface User { id: string; name: string; } interface ApiResponse<T> { data: T; status: number; }. Exception: Only use interface with explicit architect permission for specific interop requirements.",
          "metadata": {
            "rule_id": "TS_TYPE_INTERFACE_001",
            "category": "type-definitions",
            "priority": 10,
            "reason": "Interfaces are mutable, support declaration merging, and are designed for OOP patterns. Types align with FP principles of immutability and sealed definitions",
            "consequences": "Using interface allows mutation, declaration merging creates hidden dependencies, and encourages OOP patterns that violate our functional architecture",
            "philosophy": "Type vs Interface - types are immutable and sealed, interfaces are mutable and extensible. FP requires immutability",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "blocking"
          }
        }
      },
      {
        "id": "dfa978dd-b238-4bc9-aae6-13ed0a08218c",
        "payload": {
          "document": "TS_BRT_010 - Unsafe Constructor Naming: Unsafe constructors make the escape hatch explicit and should only be used for trusted data where validation already occurred. Prefix with 'unsafe' to make validation bypass explicit and document trusted data sources. Example: function unsafeUserId(str: string): UserId { return str as UserId; } // Usage: Reading from database where validation already occurred const user = await db.query('SELECT id FROM users WHERE id = ?', [validId]); const userId = unsafeUserId(user.id); // Database constraint ensures validity",
          "metadata": {
            "rule_id": "TS_BRT_010",
            "category": "brand-types",
            "priority": 8,
            "reason": "Unsafe constructors make the escape hatch explicit and should only be used for trusted data where validation already occurred",
            "consequences": "Implicit casting hides the fact that validation is being skipped, making it unclear when values might be invalid",
            "philosophy": "Unsafe Constructor Naming - prefix with 'unsafe' to make validation bypass explicit and document trusted data sources",
            "applies_to": [
              ".ts",
              ".tsx"
            ],
            "encoding_type": "principle",
            "severity": "warning"
          }
        }
      }
    ],
    "next_page_offset": null
  },
  "status": "ok",
  "time": 0.001041917
}
