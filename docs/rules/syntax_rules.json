{
  "result": {
    "points": [
      {
        "id": "01bd4ab8-e25e-44f9-90c1-66368861a8ba",
        "payload": {
          "document": "Public functions use camelCase. Private functions prepend underscore: _privateFunction",
          "metadata": {
            "rule_id": "FUNC_NAMING_001",
            "category": "syntax",
            "priority": 9,
            "reason": "Underscore immediately signals 'internal only'. Prevents accidental imports",
            "consequences": "Without clear public/private distinction, internal APIs get misused creating breaking changes",
            "philosophy": "Visual distinction between public interface and internal implementation",
            "examples": {
              "public": "processUser, validateEmail, calculateTotal",
              "private": "_hashPassword, _validateCredentials, _parseToken"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "115ba89a-4155-4088-a1f8-402c9a7fb90d",
        "payload": {
          "document": "NO abbreviations except: 1) Initialisms/acronyms (first letters of multiple words), 2) Approved whitelist: min, max, id, src, dest, temp, doc/docs, spec/specs, info, config, auth, demo, sync, async, ms, sec, hr, kb, mb, gb, tb",
          "metadata": {
            "rule_id": "NO_ABBREVIATIONS_001",
            "category": "syntax",
            "priority": 9,
            "reason": "Abbreviations create cognitive load requiring mental translation. Full words are self-documenting",
            "consequences": "Abbreviations create mystery meat code requiring decoding",
            "philosophy": "Natural language coding - write code that reads like English",
            "whitelist": {
              "mathematical": [
                "min",
                "max",
                "id",
                "src",
                "dest",
                "temp"
              ],
              "documentation": [
                "doc",
                "docs",
                "spec",
                "specs",
                "info",
                "config",
                "auth",
                "demo",
                "sync",
                "async"
              ],
              "units": [
                "ms",
                "sec",
                "hr",
                "kb",
                "mb",
                "gb",
                "tb"
              ]
            },
            "examples": {
              "wrong": [
                "calc",
                "proc",
                "util",
                "impl",
                "btn",
                "msg"
              ],
              "right": [
                "calculate",
                "process",
                "utility",
                "implementation",
                "button",
                "message"
              ]
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "17ecbfa9-76bd-468a-b531-5a3923760786",
        "payload": {
          "document": "Functions are ALWAYS camelCase. Components are ALWAYS PascalCase. Constants are ALWAYS SCREAMING_SNAKE_CASE. JSON keys are ALWAYS camelCase. No exceptions",
          "metadata": {
            "rule_id": "CASE_CONVENTIONS_001",
            "category": "syntax",
            "priority": 10,
            "reason": "Consistent casing instantly identifies the type of identifier. Reduces cognitive load",
            "consequences": "Mixed casing creates confusion about what's a function vs component vs constant",
            "philosophy": "Visual consistency enables instant recognition",
            "examples": {
              "functions": "processData, getUserInfo, calculateTotal",
              "components": "UserCard, NavigationMenu, DataTable",
              "constants": "MAX_RETRIES, API_TIMEOUT, DEFAULT_CONFIG",
              "json_keys": "firstName, isActive, accountBalance"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx",
              ".json"
            ]
          }
        }
      },
      {
        "id": "1e2cedea-b026-4ed0-9fc9-18ed5ac8120a",
        "payload": {
          "document": "Arrow function syntax OK in type signatures but prefer named type aliases: type Transform = (value: number) => number is better than inline (value: number) => number",
          "metadata": {
            "rule_id": "TYPE_ARROW_SYNTAX_001",
            "category": "syntax",
            "priority": 7,
            "reason": "Type signatures can use arrow syntax, but named aliases are clearer and more reusable. Naming can be tricky for function types",
            "consequences": "Inline function types are harder to read and not reusable",
            "philosophy": "Natural language coding - even types should have meaningful names when possible",
            "examples": {
              "acceptable": "function process(fn: (a: number) => number): number",
              "preferred": "type NumberTransform = (value: number) => number; function process(fn: NumberTransform): number"
            },
            "note": "Exception to no-arrow-functions rule - only applies to type signatures, not function implementations",
            "applies_to": [
              ".ts",
              ".tsx"
            ]
          }
        }
      },
      {
        "id": "45432b74-d608-43de-8329-92a59f1b8363",
        "payload": {
          "document": "Constants in SCREAMING_SNAKE_CASE, in constants/index.ts files, exported as named exports. Object keys within constants remain camelCase: COLORS.aquaBlue",
          "metadata": {
            "rule_id": "CONSTANTS_ORGANIZATION_001",
            "category": "syntax",
            "priority": 8,
            "reason": "SCREAMING_SNAKE_CASE makes constants unmistakable. Centralized location aids discoverability",
            "consequences": "Mixed-case constants blend in with variables",
            "philosophy": "Constants should be visually distinct and organizationally grouped",
            "examples": {
              "correct": "export const MAX_RETRIES = 3; export const API_CONFIG = { baseUrl: '...' }",
              "wrong": "export const maxRetries = 3; const apiConfig = { base_url: '...' }"
            },
            "note": "Object/map keys remain camelCase even within constants",
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "489c2ca9-088c-4e37-954e-e624a91d668c",
        "payload": {
          "document": "Initialisms and acronyms use Sentence case: innerHtml not innerHTML, AstNode not ASTNode, parseHtml not parseHTML, getApi not getAPI",
          "metadata": {
            "rule_id": "INITIALISM_CASE_001",
            "category": "syntax",
            "priority": 9,
            "reason": "Prevents garbage when converting cases: innerHtml → inner-html (clean) vs innerHTML → inner-h-t-m-l (garbage)",
            "consequences": "All-caps initialisms create unreadable snake-case and kebab-case conversions",
            "philosophy": "Visual consistency and clean case conversion",
            "examples": {
              "correct": "innerHtml, parseXml, getApi, AstNode, DomElement",
              "wrong": "innerHTML, parseXML, getAPI, ASTNode, DOMElement"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "4f200fc0-325d-46dd-a956-e4bf1dd51132",
        "payload": {
          "document": "Use semantic Toolsmith functions instead of operators and methods: isEqual not ===, length(arr) not arr.length, isNotEmpty(arr) not arr.length > 0, not(condition) instead of !condition",
          "metadata": {
            "rule_id": "SEMANTIC_FUNCTIONS_001",
            "category": "syntax",
            "priority": 10,
            "reason": "Code reads like plain English. Toolsmith functions are null-safe and self-documenting",
            "consequences": "Operators like === and ! are cryptic and error-prone. Methods like arr.length create dependencies",
            "philosophy": "Natural language coding - replace every operator with semantic equivalents",
            "examples": {
              "wrong": [
                "===",
                "!==",
                ">=",
                "arr.length",
                "!condition",
                "arr.length > 0"
              ],
              "right": [
                "isEqual",
                "isUnequal",
                "gte",
                "length(arr)",
                "not(condition)",
                "isNotEmpty(arr)"
              ]
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "50e509f5-995c-40e3-97b3-4e948bbfa955",
        "payload": {
          "document": "Inner functions in curried functions should be named after what they CARRY (the enclosed value), not their parameter. Example: function add(augend) { return function addToAugend(addend) { return augend + addend } }",
          "metadata": {
            "rule_id": "FUNC_CLOSURE_NAMING_001",
            "category": "syntax",
            "priority": 9,
            "reason": "The parameter is visible in the signature. The carried/enclosed value is hidden - naming it makes the closure's purpose clear",
            "consequences": "Generic names like 'addY' don't communicate what value is being carried in the closure",
            "philosophy": "Natural language coding - function names should express intent and captured state",
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "510db60e-83db-4750-acb3-6ad8f33bc421",
        "payload": {
          "document": "NEVER use arrow functions. Always use named function declarations with explicit blocks and return statements",
          "metadata": {
            "rule_id": "FUNC_DECLARATION_001",
            "category": "syntax",
            "priority": 10,
            "reason": "Named functions are traceable in stack traces. 'function' keyword is explicit. Forces explicit returns",
            "consequences": "Arrow functions create debugging nightmares and cognitive ambiguity",
            "philosophy": "Natural language coding - functions should be named and explicit",
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ],
            "exceptions": [
              "Test files only - but even there, prefer named functions"
            ]
          }
        }
      },
      {
        "id": "9040eb2f-209f-4636-ad4f-acd1ba50e9f9",
        "payload": {
          "document": "Types in PascalCase, in types/index.ts files, exported as named exports, imported with 'type' keyword",
          "metadata": {
            "rule_id": "TYPE_NAMING_001",
            "category": "syntax",
            "priority": 9,
            "reason": "PascalCase distinguishes types from values. 'type' import prevents runtime inclusion",
            "consequences": "Without 'type' keyword, types can bloat bundles",
            "philosophy": "Clear distinction between types and runtime values",
            "examples": {
              "correct": "import type { User, Product } from '../types/index.ts'",
              "wrong": "import { User, Product } from '../types/index.ts'"
            },
            "applies_to": [
              ".ts",
              ".tsx"
            ]
          }
        }
      },
      {
        "id": "a4eb7b28-5065-4980-bc87-968398bc7f94",
        "payload": {
          "document": "Write happy path first: if (isNotEmpty(arr)) { process } return null - NOT if (isEmpty(arr)) { return null } process",
          "metadata": {
            "rule_id": "HAPPY_PATH_FIRST_001",
            "category": "syntax",
            "priority": 9,
            "reason": "Happy path should be the main branch, not buried in else clauses. Easier to understand the intended flow",
            "consequences": "Error-first code obscures the main purpose and creates nested logic",
            "philosophy": "Natural language coding - lead with what you want to accomplish, not what might go wrong",
            "examples": {
              "wrong": "if (arr.length === 0) { return null } return arr.map(...)",
              "right": "if (isNotEmpty(arr)) { return map(transform)(arr) } return null"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "b6b08f9e-838f-41d8-b35a-ca0bd0b08924",
        "payload": {
          "document": "Extract operations for readability instead of inline: const multiplyBy7 = multiply(7); map(multiplyBy7)(numbers) - NOT map(n => n * 7)(array)",
          "metadata": {
            "rule_id": "EXTRACT_FOR_READABILITY_001",
            "category": "syntax",
            "priority": 9,
            "reason": "Named operations read like English. Inline operations require mental parsing",
            "consequences": "Inline operations create cognitive load and reduce code comprehension",
            "philosophy": "Natural language coding - give every operation a meaningful name",
            "examples": {
              "wrong": "map(n => n * 7)([1,2,3,4,5])",
              "right": "const multiplyBy7 = multiply(7); map(multiplyBy7)(numbers)"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "e9a795a8-4d78-4864-971a-dd4207a8b955",
        "payload": {
          "document": "Component props are named 'Props', exported as named export, placed ABOVE the component",
          "metadata": {
            "rule_id": "COMPONENT_PROPS_001",
            "category": "syntax",
            "priority": 8,
            "reason": "Props are fundamental to components - deserve prime visibility. Generic name makes sense in context",
            "consequences": "Props buried below component are harder to find",
            "philosophy": "Important things should be visible first",
            "examples": {
              "correct": "export type Props = { user: User }; export default function UserCard({ user }: Props)",
              "wrong": "export default function UserCard({ user }: UserCardProps) // props defined elsewhere"
            },
            "note": "Rename on import when needed: import type { Props as UserCardProps }",
            "applies_to": [
              ".tsx",
              ".jsx"
            ]
          }
        }
      },
      {
        "id": "f07eca2e-595f-449e-831d-d664911aff5c",
        "payload": {
          "document": "Arrow functions OK in type signatures: (a: number) => number, but better to create named type aliases first: type NumberTransform = (value: number) => number",
          "metadata": {
            "rule_id": "ARROW_TYPES_CLARIFICATION_001",
            "category": "syntax",
            "priority": 7,
            "reason": "Type signatures can use arrow syntax, but named aliases are clearer and more reusable",
            "consequences": "Inline function types are less readable than named type aliases",
            "philosophy": "Natural language coding - give types meaningful names too",
            "examples": {
              "acceptable": "function transform(fn: (a: number) => number): number",
              "better": "type NumberTransform = (value: number) => number; function transform(fn: NumberTransform): number"
            },
            "applies_to": [
              ".ts",
              ".tsx"
            ]
          }
        }
      },
      {
        "id": "fc55e3a6-35cb-48e3-9cdb-6aa0fa517476",
        "payload": {
          "document": "Names must be readable as natural language. Use complete words and phrases that clearly express intent. Code should read like plain English",
          "metadata": {
            "rule_id": "NATURAL_LANGUAGE_NAMING_001",
            "category": "syntax",
            "priority": 10,
            "reason": "Code is read far more often than written, so optimize for reader comprehension over writer convenience",
            "consequences": "Cryptic, overly terse, or clever names require mental translation and slow comprehension",
            "philosophy": "Natural language coding - code should be self-documenting",
            "examples": {
              "correct": "calculateUserAccountBalance, isUserEmailAddressVerified, sendWelcomeEmailToNewUser",
              "wrong": "calcUsrBal, isUsrEmailVerif, sndWelcEmail"
            },
            "applies_to": [
              ".ts",
              ".tsx",
              ".js",
              ".jsx"
            ]
          }
        }
      }
    ],
    "next_page_offset": null
  },
  "status": "ok",
  "time": 0.00317
}
