# Boxed Functions Implementation Guide
# Complete instructions for creating monadic versions of Toolsmith functions

overview: |
  Boxed functions are monadic wrappers around vanilla Toolsmith functions.
  They handle Result and Validation monads automatically, defaulting to Result.
  The rule: "Validation wins" - if ANY input is Validation, output is Validation.

critical_rules:
  - ONE function per file, exported as DEFAULT on same line as definition
  - Function name is the folder name (e.g., /add/index.ts exports function add)
  - ALL functions must be CURRIED
  - NO arrow functions - use traditional function declarations
  - NO TypeScript "any" type - everything must be properly typed
  - NO "unknown" type - use Value, Serializable, or PrimitiveValue from types/index.ts
  - NO methods - only pure functions (use isResult(x) not x.isResult())
  - Inner functions named semantically for what was captured (e.g., addToAugend, divideByDivisor)
  - camelCase for all names
  - Single descriptive comment at top (//++) - no other comments needed
  - Delegate ALL work to vanilla functions - boxed are just wrappers
  - NO SEMICOLONS - never use semicolons at end of statements
  - USE TABS - always use tabs for indentation, never spaces
  - EXTRACT ALL LAMBDAS - inline functions passed to map/reduce/etc go in separate files
  - HAPPY PATH FIRST - check valid conditions, not invalid ones (if isNumber, not if !isNumber)
  - NO ! OPERATOR - it's nearly invisible; use `not` function if forced to negate
  - ALL if statements require blocks {} so they're multi-line with blank lines above/below
  - Imports grouped by type, alphabetical within groups, blank line between groups
  - Multi-line statements need blank line above and below
  - No blank lines at start/end of blocks
  - "Whitespace inside braces: { a: 1, b: 2 } with spaces after colons"
  - Never more than one blank line in a row
  - Group like statements together (multiple consts, multiple ifs), blank line before different statement types
  - Always blank line before return statements

directory_structure: |
  libraries/toolsmith/src/
  ├── vanilla/          # Original pure functions (DO NOT MODIFY)
  │   └── category/
  │       └── functionName/
  │           └── index.ts
  └── boxed/           # Monadic versions
      ├── lift/        # Helper functions for lifting
      │   ├── liftUnary/
      │   └── liftBinary/
      └── category/    # Same structure as vanilla
          └── functionName/
              └── index.ts

imports_pattern: |
  # Import groups (alphabetical within each group, blank line between groups):
  # 1. Type imports (alphabetical)
  # 2. Internal default imports (alphabetical)

  import type { Result } from "../../../monads/result/types/index.ts"
  import type { Validation } from "../../../types/Validation/index.ts"

  import liftBinary from "../../lift/liftBinary/index.ts"
  import vanillaFunctionName from "../../../vanilla/category/functionName/index.ts"

implementation_patterns:
  unary_function:
    description: "For functions that take one argument"
    template: |
      import vanillaFunctionName from "../../../vanilla/category/functionName/index.ts"
      import liftUnary from "../../lift/liftUnary/index.ts"

      //++ Boxed version of functionName that works with Result/Validation monads
      const functionName = liftUnary(vanillaFunctionName)

      export default functionName

    example: |
      # File: libraries/toolsmith/src/boxed/math/negate/index.ts
      import vanillaNegate from "../../../vanilla/math/negate/index.ts"
      import liftUnary from "../../lift/liftUnary/index.ts"

      //++ Boxed version of negate that works with Result/Validation monads
      const negate = liftUnary(vanillaNegate)
      export default negate

  binary_function:
    description: "For curried functions that take two arguments"
    template: |
      import vanillaFunctionName from "../../../vanilla/category/functionName/index.ts"
      import liftBinary from "../../lift/liftBinary/index.ts"

      //++ Boxed version of functionName that works with Result/Validation monads
      const functionName = liftBinary(vanillaFunctionName)

      export default functionName

    note: "IMPORTANT: Inner functions in vanilla versions have semantic names (e.g., addToAugend, divideByDivisor)"

    examples:
      add: |
        # File: libraries/toolsmith/src/boxed/math/add/index.ts
        # Vanilla: First param is augend, second is addend
        # Vanilla inner function: addToAugend
        import vanillaAdd from "../../../vanilla/math/add/index.ts"
        import liftBinary from "../../lift/liftBinary/index.ts"

        //++ Boxed version of add that works with Result/Validation monads
        const add = liftBinary(vanillaAdd)
        export default add

      divide: |
        # File: libraries/toolsmith/src/boxed/math/divide/index.ts
        # Vanilla: First param is DIVISOR, second is dividend
        # Vanilla inner function: divideByDivisor (captures divisor!)
        import vanillaDivide from "../../../vanilla/math/divide/index.ts"
        import liftBinary from "../../lift/liftBinary/index.ts"

        //++ Boxed version of divide that works with Result/Validation monads
        const divide = liftBinary(vanillaDivide)
        export default divide

      subtract: |
        # File: libraries/toolsmith/src/boxed/math/subtract/index.ts
        # Vanilla: First param is subtrahend, second is minuend
        # Vanilla inner function: subtractFromMinuend
        import vanillaSubtract from "../../../vanilla/math/subtract/index.ts"
        import liftBinary from "../../lift/liftBinary/index.ts"

        //++ Boxed version of subtract that works with Result/Validation monads
        const subtract = liftBinary(vanillaSubtract)
        export default subtract

  ternary_function:
    description: "For curried functions that take three arguments"
    needs_implementation: "Create liftTernary first, then use pattern"
    template: |
      import vanillaFunctionName from "../../../vanilla/category/functionName/index.ts"
      import liftTernary from "../../lift/liftTernary/index.ts"

      //++ Boxed version of functionName that works with Result/Validation monads
      const functionName = liftTernary(vanillaFunctionName)

      export default functionName

    example: |
      # File: libraries/toolsmith/src/boxed/math/clamp/index.ts
      import vanillaClamp from "../../../vanilla/math/clamp/index.ts"
      import liftTernary from "../../lift/liftTernary/index.ts"

      //++ Boxed version of clamp that works with Result/Validation monads
      const clamp = liftTernary(vanillaClamp)
      export default clamp

  quaternary_function:
    description: "For curried functions that take four arguments"
    needs_implementation: "Create liftQuaternary first, then use pattern"
    template: |
      import vanillaFunctionName from "../../../vanilla/category/functionName/index.ts"
      import liftQuaternary from "../../lift/liftQuaternary/index.ts"

      //++ Boxed version of functionName that works with Result/Validation monads
      const functionName = liftQuaternary(vanillaFunctionName)

      export default functionName

  n_ary_function:
    description: "For functions with 5+ arguments"
    needs_implementation: "Create liftN that handles any arity"
    template: |
      import vanillaFunctionName from "../../../vanilla/category/functionName/index.ts"
      import liftN from "../../lift/liftN/index.ts"

      //++ Boxed version of functionName that works with Result/Validation monads
      const functionName = liftN(5)(vanillaFunctionName) # specify arity

      export default functionName

lift_helpers:
  liftUnary:
    location: libraries/toolsmith/src/boxed/lift/liftUnary/index.ts
    implementation: |
      import type { Result } from "../../../monads/result/types/index.ts"
      import type { Validation } from "../../../types/Validation/index.ts"
      import isResult from "../../../monads/result/isResult/index.ts"
      import isValidation from "../../../monads/validation/isValidation/index.ts"
      import resultMap from "../../../monads/result/map/index.ts"
      import validationMap from "../../../monads/validation/map/index.ts"
      import ok from "../../../monads/result/ok/index.ts"

      //++ Lifts a unary function to work with Result/Validation monads
      export default function liftUnary<A, B, E>(fn: (a: A) => B) {
      	return function lifted(
      		ma: A | Result<E, A> | Validation<E[], A>
      	): Result<E, B> | Validation<E[], B> {
      		if (isValidation(ma)) {
      			return validationMap(fn)(ma)
      		}

      		if (isResult(ma)) {
      			return resultMap(fn)(ma)
      		}

      		return ok(fn(ma))
      	}
      }

  liftBinary:
    location: libraries/toolsmith/src/boxed/lift/liftBinary/index.ts
    for_curried_functions: "ONLY for curried binary functions: (a) => (b) => c"
    not_for: "NOT for uncurried functions: (a, b) => c"
    implementation: |
      import type { Result } from "../../../monads/result/types/index.ts"
      import type { Validation } from "../../../types/Validation/index.ts"
      import isResult from "../../../monads/result/isResult/index.ts"
      import isValidation from "../../../monads/validation/isValidation/index.ts"
      import resultMap2 from "../../../monads/result/map2/index.ts"
      import validationMap2 from "../../../monads/validation/map2/index.ts"
      import ok from "../../../monads/result/ok/index.ts"
      import success from "../../../monads/validation/success/index.ts"

      //++ Lifts a curried binary function to work with Result/Validation monads
      //++ Note: Inner functions should be named semantically in actual implementations
      export default function liftBinary<A, B, C, E>(fn: (a: A) => (b: B) => C) {
      	return function liftedFirst(
      		ma: A | Result<E, A> | Validation<E[], A>
      	) {
      		return function liftedSecond(
      			mb: B | Result<E, B> | Validation<E[], B>
      		): Result<E, C> | Validation<E[], C> {
      			if (isValidation(ma) || isValidation(mb)) {
      				const aVal = isValidation(ma) ? ma : success(ma as A)
      				const bVal = isValidation(mb) ? mb : success(mb as B)

      				return validationMap2(fn)(aVal)(bVal)
      			}

      			const aResult = isResult(ma) ? ma : ok(ma as A)
      			const bResult = isResult(mb) ? mb : ok(mb as B)

      			return resultMap2(fn)(aResult)(bResult)
      		}
      	}
      }

  liftTernary:
    needs_implementation: true
    pattern: "Similar to liftBinary but with map3 functions"

  liftQuaternary:
    needs_implementation: true
    pattern: "Similar to liftBinary but with map4 functions"
    note: |
      Rarely needed - consider refactoring to group related params:
      Instead of: fn(a)(b)(c)(d)
      Consider:   fn(config: {a, b})(c)(d) if a & b are always configured together

  liftN:
    needs_implementation: true
    pattern: "Generic version that handles any arity"
    warning: |
      Code smell! If you need this, your function has too many curried parameters.
      Group related config that won't be partially applied alone:
      BAD:     function doThing(a)(b)(c)(d)(e)
      WRONG:   function doThing(options: {a, b, c, d, e})  # Defeats currying!
      GOOD:    function doThing(config: {a, b, c})(d)(e)   # Config first, then curried params

      Example: formatNumber(config: {locale, precision})(value)
      - Config groups formatting options you'd set once
      - Value stays separate for mapping over arrays

usage_examples:
  plain_values: |
    import add from "@toolsmith/boxed/math/add"

    # Plain values default to Result
    add(5)(10)  # Returns: {_tag: "Ok", value: 15}

  result_monad: |
    import add from "@toolsmith/boxed/math/add"
    import ok from "@toolsmith/monads/result/ok"
    import error from "@toolsmith/monads/result/error"

    # Result propagates
    add(ok(5))(ok(10))           # {_tag: "Ok", value: 15}
    add(error("bad"))(ok(10))    # {_tag: "Error", error: "bad"}
    add(ok(5))(error("bad"))     # {_tag: "Error", error: "bad"}

  validation_monad: |
    import add from "@toolsmith/boxed/math/add"
    import success from "@toolsmith/monads/validation/success"
    import failure from "@toolsmith/monads/validation/failure"

    # Validation propagates and accumulates
    add(success(5))(success(10))              # {_tag: "Valid", value: 15}
    add(failure(["e1"]))(success(10))         # {_tag: "Invalid", errors: ["e1"]}
    add(failure(["e1"]))(failure(["e2"]))     # {_tag: "Invalid", errors: ["e1", "e2"]}

  mixed_monads: |
    import add from "@toolsmith/boxed/math/add"
    import ok from "@toolsmith/monads/result/ok"
    import success from "@toolsmith/monads/validation/success"

    # Validation "wins" over Result
    add(ok(5))(success(10))      # {_tag: "Valid", value: 15}
    add(success(5))(ok(10))      # {_tag: "Valid", value: 15}
    add(success(5))(10)          # {_tag: "Valid", value: 15}

  pipeline: |
    import pipe from "@toolsmith/pipe"
    import add from "@toolsmith/boxed/math/add"
    import multiply from "@toolsmith/boxed/math/multiply"
    import success from "@toolsmith/monads/validation/success"

    # Monad type propagates through pipeline
    pipe(
      10,              # Plain value
      add(5),          # Result.Ok(15)
      multiply(2)      # Result.Ok(30)
    )

    pipe(
      success(10),     # Start with Validation
      add(5),          # Validation.Valid(15)
      multiply(2)      # Validation.Valid(30)
    )

implementation_checklist:
  - "1. Check vanilla function arity (number of curried parameters)"
  - "2. Create lift helper if it doesn't exist (liftUnary, liftBinary, etc.)"
  - "3. Create folder: libraries/toolsmith/src/boxed/[category]/[functionName]"
  - "4. Create index.ts with proper imports (all default, full paths)"
  - "5. Use const assignment pattern with lift helper"
  - "6. Export default on same line as const declaration"
  - "7. Add single descriptive comment at top"
  - "8. Test with Result, Validation, and plain values"

testing_rules:
  critical_rules:
    - "Test file MUST be named index.test.ts in same folder as index.ts"
    - "Use Deno.test (with t.step if useful for organizing test cases)"
    - "Use fast-check for property-based testing of edge cases"
    - "NO MOCKS - these are integration tests, not unit tests"
    - "Test behavior, not implementation - use the PUBLIC API only"
    - "NEVER reach into monad internals - use isOk/isError/isValid/isInvalid"
    - "NEVER create monads by hand - use ok/error/success/failure functions"
    - "Shoot for 100% line and branch coverage"
    - "Find bugs now with fast-check, not in production"

  framework_setup: |
    import { assert, assertEquals, assertStrictEquals } from "jsr:@std/assert"
    import * as fc from "npm:fast-check"

  public_api_usage:
    explanation: |
      Always use the monad's public API functions. Never inspect internal structure.
      This ensures tests remain valid even if implementation changes.

    bad_example: |
      // BAD - depends on implementation details
      const result = boxedFunction(5)
      assertEquals(result._tag, "Ok")
      assertEquals(result.value, 10)

    good_example: |
      // GOOD - uses public API
      import isOk from "../../../monads/result/isOk/index.ts"
      import getOr from "../../../monads/result/getOr/index.ts"

      const result = boxedFunction(5)
      assert(isOk(result))
      assertEquals(getOr(0)(result), 10)

  test_structure:
    basic_test: |
      Deno.test("functionName - basic behavior", () => {
        // Test the happy path with plain values
        const result = functionName(input)
        assert(isOk(result))
        assertEquals(getOr(null)(result), expectedOutput)
      })

    with_steps: |
      Deno.test("functionName - comprehensive", async (t) => {
        await t.step("plain values default to Result", () => {
          const result = functionName(5)
          assert(isOk(result))
        })

        await t.step("Result monad propagates", () => {
          const result = functionName(ok(5))
          assert(isOk(result))
        })

        await t.step("Validation monad propagates", () => {
          const result = functionName(success(5))
          assert(isValid(result))
        })
      })

  what_to_test:
    for_lift_functions:
      - "Plain values → wraps in Result.Ok"
      - "Result.Ok → maps function correctly"
      - "Result.Error → propagates error"
      - "Validation.Valid → maps function correctly"
      - "Validation.Invalid → propagates errors"
      - "Validation wins rule: Result + Validation → Validation"
      - "Error accumulation in Validation (for binary/ternary)"
      - "Property tests with random inputs using fast-check"

    for_boxed_functions:
      - "All vanilla function behaviors work through monad"
      - "Plain values default to Result"
      - "Result monad propagation (Ok and Error)"
      - "Validation monad propagation (Valid and Invalid)"
      - "Mixed monad handling (Validation wins)"
      - "Error accumulation in Validation for multi-arg functions"
      - "Currying behavior preserved"
      - "Array overloads work correctly (if applicable)"
      - "Edge cases: NaN, Infinity, very large/small numbers"
      - "Property-based tests for mathematical properties"

  property_testing_examples:
    commutativity: |
      // For commutative operations like add
      fc.assert(
        fc.property(fc.integer(), fc.integer(), (a, b) => {
          const resultAB = add(a)(b)
          const resultBA = add(b)(a)
          assert(isOk(resultAB))
          assert(isOk(resultBA))
          assertEquals(getOr(0)(resultAB), getOr(0)(resultBA))
        })
      )

    associativity: |
      // For associative operations
      fc.assert(
        fc.property(fc.integer(), fc.integer(), fc.integer(), (a, b, c) => {
          const left = add(add(a)(b))(c)
          const right = add(a)(add(b)(c))
          assertEquals(getOr(0)(left), getOr(0)(right))
        })
      )

    identity: |
      // For operations with identity elements
      fc.assert(
        fc.property(fc.integer(), (n) => {
          const result = add(0)(n)
          assertEquals(getOr(null)(result), n)
        })
      )

    edge_cases: |
      // Test with extreme values
      fc.assert(
        fc.property(
          fc.oneof(
            fc.constant(Number.MAX_SAFE_INTEGER),
            fc.constant(Number.MIN_SAFE_INTEGER),
            fc.constant(0),
            fc.constant(-0),
            fc.double({ min: -1e10, max: 1e10 })
          ),
          (n) => {
            const result = functionName(n)
            // Assert expected behavior
          }
        )
      )

  coverage_guidelines:
    - "Aim for 100% line coverage"
    - "Aim for 100% branch coverage"
    - "If a line or branch cannot reasonably be tested, document why"
    - "Use // deno-coverage-ignore-file or // deno-coverage-ignore-next-line sparingly"
    - "Every code path should be exercised by tests"
    - "Use fast-check to discover untested edge cases"

  test_organization:
    - "Group related tests using t.step"
    - "Test happy path first, then error cases"
    - "Test monad behavior separately from function behavior"
    - "Keep tests focused - one assertion per concept"
    - "Use descriptive test names that explain what is being tested"

  example_test_file: |
    import { assert, assertEquals } from "jsr:@std/assert"
    import * as fc from "npm:fast-check"

    import error from "../../../monads/result/error/index.ts"
    import getOr from "../../../monads/result/getOr/index.ts"
    import isOk from "../../../monads/result/isOk/index.ts"
    import ok from "../../../monads/result/ok/index.ts"
    import failure from "../../../monads/validation/failure/index.ts"
    import getOrElse from "../../../monads/validation/getOrElse/index.ts"
    import isValid from "../../../monads/validation/isValid/index.ts"
    import success from "../../../monads/validation/success/index.ts"

    import add from "./index.ts"

    Deno.test("add - plain values default to Result", () => {
      const result = add(2)(3)

      assert(isOk(result))
      assertEquals(getOr(0)(result), 5)
    })

    Deno.test("add - Result monad behavior", async (t) => {
      await t.step("Ok + Ok → Ok", () => {
        const result = add(ok(2))(ok(3))
        assert(isOk(result))
        assertEquals(getOr(0)(result), 5)
      })

      await t.step("Error + Ok → Error", () => {
        const result = add(error("bad"))(ok(3))
        assert(isOk(result) === false)
      })
    })

    Deno.test("add - Validation monad behavior", async (t) => {
      await t.step("Valid + Valid → Valid", () => {
        const result = add(success(2))(success(3))
        assert(isValid(result))
        assertEquals(getOrElse(() => 0)(result), 5)
      })

      await t.step("Invalid + Valid → Invalid", () => {
        const result = add(failure(["e1"]))(success(3))
        assert(isValid(result) === false)
      })
    })

    Deno.test("add - property: commutativity", () => {
      fc.assert(
        fc.property(fc.integer(), fc.integer(), (a, b) => {
          const ab = add(a)(b)
          const ba = add(b)(a)
          assertEquals(getOr(0)(ab), getOr(0)(ba))
        })
      )
    })

common_mistakes_to_avoid:
  - "DON'T use arrow functions - use traditional function declarations"
  - "DON'T use named imports - everything is default export"
  - "DON'T forget the .ts extension on imports"
  - "DON'T use 'any' type - properly type everything"
  - "DON'T use 'unknown' type - use Value, Serializable, or PrimitiveValue"
  - "DON'T call methods - use pure functions only"
  - "DON'T modify vanilla functions - only wrap them"
  - "DON'T add extra comments - just the one at the top"
  - "DON'T create barrel files (index.ts that re-exports)"
  - "DON'T forget to curry - ALL functions must be curried"
  - "DON'T mix Result and Validation incorrectly - Validation always wins"

happy_path_pattern:
  explanation: |
    Always check for valid conditions first, not invalid ones.
    Handle the normal case inside the if block, error cases outside.
    Never use the ! operator - it's nearly invisible in code.
    Guards should be comprehensive - avoid redundant checks.

  bad_example: |
    // BAD - checking for invalid condition (even with not)
    if (not(isNumber(x))) {
      return NaN
    }
    return process(x)

    // BAD - still checking the negative case first
    if (not(valid)) {
      return handleError()
    }
    return process()

    // BAD - redundant checks
    if (isArray(arr) && isEmpty(arr)) {  // isEmpty already checks isArray!
      return defaultValue
    }

  good_example: |
    // GOOD - happy path first
    if (isNumber(x)) {
      return process(x)  // Happy path inside
    }

    return NaN  // Error case outside

    // GOOD - when you MUST check negative, use not function
    import not from "../predicates/not/index.ts"

    // Only use not when there's no positive alternative
    if (hasPermission(user)) {
      return processRequest()
    }

    // Sometimes negation is clearer for guards
    if (not(isEmpty(errors))) {
      return handleErrors(errors)
    }

    // GOOD - intelligent guards include type checks
    if (isEmpty(arr)) {  // isEmpty checks isArray internally
      return defaultValue
    }

    if (isNotEmpty(arr)) {  // Already validates it's an array
      return process(arr)
    }

lambda_extraction_rule:
  explanation: |
    ALL inline functions must be extracted to their own files, even simple ones
    passed to map, reduce, filter, etc. Each gets its own subfolder with semantic name.
    Private functions start with underscore.

  bad_example: |
    // BAD - inline lambda
    reduce((acc, n) => acc + (n * n))(ADDITIVE_IDENTITY)(numbers)

  good_example: |
    // GOOD - extracted and named
    // In ./_squareThenSum/index.ts (private, note the underscore)
    import square from "@sitebender/toolsmith/vanilla/math/square/index.ts"

    //++ Adds the square of a number to a sum accumulator
    export default function _squareThenSum(sum: number): (n: number) => number {
      return function squareAndAddToSum(n: number): number {
        return sum + square(n)
      }
    }

    // In the main file
    import _squareThenSum from "./_squareThenSum/index.ts"
    reduce(_squareThenSum)(ADDITIVE_IDENTITY)(numbers)

  naming_convention:
    - Private helpers start with underscore: _squareThenSum
    - Name describes the operation semantically
    - Even simple functions like identity get their own files
    - Inner functions also named semantically based on captured values

type_system:
  explanation: |
    Instead of using 'any' or 'unknown', use our specific type definitions from types/index.ts:

    - PrimitiveValue: string | number | boolean | null | bigint | symbol
      Use for: functions that only handle primitives

    - Serializable: PrimitiveValue | Arrays | Objects | Temporal types | etc.
      Use for: data that needs to be stored, transmitted, or serialized

    - Value: Everything including Serializable + Function + WeakMap + WeakSet + Promise
      Use for: validators, predicates, functions that must handle ANY JavaScript value

    NOTE: undefined is intentionally excluded - use optional parameters (value?: Value)

  examples:
    validator: "function isString(value?: Value): value is string"
    converter: "function toString(value?: Serializable): string"
    predicate: "function not(value: Value): boolean"

type_signatures:
  result: "Result<E, T> where E is error type, T is success type"
  validation: "Validation<E[], T> where E[] is array of errors, T is success type"
  lifted_unary: "(a: A | Result<E, A> | Validation<E[], A>) => Result<E, B> | Validation<E[], B>"
  lifted_binary: "(a: A | Result<E, A> | Validation<E[], A>) => (b: B | Result<E, B> | Validation<E[], B>) => Result<E, C> | Validation<E[], C>"

notes: |
  - The "boxed" metaphor: values go in boxes, functions work with boxed values
  - Result is the default for plain values (most common use case)
  - Validation "infects" the computation (for error accumulation)
  - No cognitive overhead at call site - same interface as vanilla
  - Type propagation is automatic through pipelines
  - All actual work delegated to vanilla functions
  - Naming convention: "config" for necessary parameters, "options" for optional ones
  - Config/options object should be FIRST parameter to get it out of the way
  - Only group parameters that are configured together, not partially applied alone
