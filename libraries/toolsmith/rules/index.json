{
	"version": "1.0.0",
	"lastUpdated": "2025-01-14",
	"scope": "toolsmith",
	"description": "Toolsmith-specific rules that extend the root rules. These are combined with root rules to form complete toolsmith guidelines.",
	"monadSemantics": {
		"fundamentalPrinciple": "Each monad serves a SPECIFIC computational context. Using the wrong monad is a semantic error.",
		"Either": {
			"purpose": "Disjoint union - branching between two exclusive possibilities",
			"correctUsage": [
				"Parse as JSON or XML",
				"Use primary or fallback strategy",
				"Return cached or fresh data",
				"Choose between two valid paths"
			],
			"forbiddenUsage": [
				"Error handling (use Result)",
				"Null checking (use Maybe)",
				"Validation (use Validation)"
			],
			"branches": {
				"Left": "First possible branch (NOT error)",
				"Right": "Second possible branch (NOT success)"
			},
			"note": "Either is about CHOICE, not CORRECTNESS. Both branches are equally valid outcomes."
		},
		"Result": {
			"purpose": "Operations that can fail - explicit error handling",
			"correctUsage": [
				"File operations",
				"Network requests",
				"Parsing with potential failure",
				"Any operation with error conditions"
			],
			"branches": {
				"Ok": "Successful computation result",
				"Err": "Error condition with details"
			},
			"note": "Result is Either with semantic clarity for error handling. Use Result, not Either, for errors."
		},
		"Validation": {
			"purpose": "Accumulating multiple errors - fail-all pattern",
			"correctUsage": [
				"Form validation with multiple fields",
				"Configuration checking",
				"Batch processing where all errors matter",
				"Input sanitization with multiple rules"
			],
			"branches": {
				"Valid": "All validations passed",
				"Invalid": "One or more validations failed (NonEmptyArray of errors)"
			},
			"note": "Unlike Result which fails fast, Validation accumulates ALL errors before returning."
		},
		"Maybe": {
			"purpose": "Explicit handling of nullable/optional values",
			"correctUsage": [
				"Optional configuration values",
				"Possibly missing data",
				"Safe navigation of nested structures",
				"Converting null/undefined to type-safe values"
			],
			"branches": {
				"Just": "Value is present",
				"Nothing": "Value is absent"
			},
			"note": "Maybe makes the absence of value explicit and composable."
		},
		"Option": {
			"status": "DEPRECATED",
			"note": "Option is an alias for Maybe. Use Maybe exclusively. Option exists only for compatibility and will be removed."
		},
		"IO": {
			"purpose": "Encapsulate side effects while maintaining referential transparency",
			"correctUsage": [
				"Console operations",
				"DOM manipulation",
				"Random number generation",
				"Current time retrieval"
			],
			"note": "IO actions are descriptions of effects, not the effects themselves. They only execute when explicitly run."
		},
		"Task": {
			"purpose": "Asynchronous computations that always succeed",
			"correctUsage": [
				"Async operations without failure",
				"Delayed computations",
				"Promise wrapping"
			],
			"note": "For async operations that can fail, use Task<Result<E, A>> or TaskEither."
		},
		"State": {
			"purpose": "Stateful computations in pure functional style",
			"correctUsage": [
				"Random number generation with seed",
				"Unique ID generation",
				"Accumulating values through computation",
				"Threading configuration through functions"
			],
			"note": "State monad threads state through computations without mutation."
		},
		"Reader": {
			"purpose": "Dependency injection and shared environment",
			"correctUsage": [
				"Accessing configuration",
				"Dependency injection",
				"Implicit parameters",
				"Environment-dependent computations"
			],
			"note": "Reader allows functions to access shared context without explicit passing."
		},
		"Writer": {
			"purpose": "Computations with accumulated output",
			"correctUsage": [
				"Logging alongside computation",
				"Collecting warnings",
				"Building up strings/lists during computation",
				"Tracing execution paths"
			],
			"note": "Writer accumulates output values alongside the main computation."
		},
		"Future": {
			"purpose": "Lazy asynchronous computations",
			"correctUsage": [
				"Deferred async operations",
				"Cancellable computations",
				"Resource-safe async operations"
			],
			"note": "Unlike Task, Future is lazy and only runs when explicitly executed."
		}
	},
	"toolsmithPrinciples": {
		"zeroDependencies": {
			"rule": "The toolsmith has ZERO external dependencies",
			"exceptions": ["Deno built-ins", "Temporal (until universal)"],
			"rationale": "Toolsmith must be self-contained and dependency-free"
		},
		"pureUtilities": {
			"rule": "Every function must be pure unless explicitly marked for I/O",
			"details": [
				"No hidden side effects",
				"No mutations",
				"Deterministic outputs",
				"Referentially transparent"
			]
		},
		"noBarrelFiles": {
			"rule": "NEVER create index.ts that re-exports from multiple files",
			"correct": "Import directly from specific function folders",
			"incorrect": "Creating a barrel file that exports * from './functions'"
		},
		"functionGranularity": {
			"rule": "Each function gets its own folder, no matter how small",
			"structure": "functionName/index.ts (and optionally index.test.ts)",
			"rationale": "Consistent structure, easy deletion, clear dependencies"
		}
	},
	"implementationRules": {
		"monadLaws": {
			"required": "All monads MUST satisfy the three monad laws",
			"laws": [
				"Left Identity: M.of(a).chain(f) === f(a)",
				"Right Identity: m.chain(M.of) === m",
				"Associativity: m.chain(f).chain(g) === m.chain(x => f(x).chain(g))"
			],
			"testing": "Property-based tests should verify these laws"
		},
		"consistency": {
			"namingConventions": {
				"constructors": [
					"of",
					"just",
					"nothing",
					"ok",
					"err",
					"valid",
					"invalid"
				],
				"transformers": ["map", "chain", "flatMap", "bind"],
				"extractors": ["fold", "getOrElse", "extract", "run"],
				"predicates": [
					"isJust",
					"isNothing",
					"isOk",
					"isErr",
					"isValid",
					"isInvalid"
				]
			},
			"chainVsFlatMap": "Use 'chain' as the standard name, 'flatMap' as alias if needed"
		},
		"currying": {
			"rule": "Utility functions should be curried for composition",
			"example": "map(fn)(monad) not map(monad, fn)",
			"rationale": "Enables partial application and pipeline composition"
		},
		"inference": {
			"rule": "Design APIs for optimal TypeScript inference",
			"approach": "Left-to-right inference flow",
			"example": "fold<A, B>(onSuccess)(onError)(result)"
		}
	},
	"documentationRules": {
		"everyFunction": {
			"rule": "EVERY exported function MUST have Envoy documentation",
			"required": [
				"//++ Description comment",
				"//?? [EXAMPLE] with real usage",
				"Type signature must be explicit"
			]
		},
		"monadExamples": {
			"rule": "Each monad operation must show practical examples",
			"include": [
				"Basic usage",
				"Composition example",
				"Common pitfalls"
			]
		},
		"noErrorHandlingInEither": {
			"rule": "NEVER document Either as error handling",
			"correct": "Document Either for branching logic",
			"incorrect": "Referring to Left as 'error' or Right as 'success'"
		}
	},
	"testingRules": {
		"coverage": {
			"requirement": "100% coverage for all toolsmith functions",
			"location": "Same folder as function (index.test.ts)",
			"framework": "Deno.test with @std/expect"
		},
		"monadLawTests": {
			"requirement": "Each monad must have law verification tests",
			"laws": ["Functor laws", "Applicative laws", "Monad laws"],
			"approach": "Property-based testing where applicable"
		},
		"exampleVerification": {
			"rule": "All //?? [EXAMPLE] comments must be runnable tests",
			"rationale": "Documentation examples must always work"
		}
	},
	"migrationNotes": {
		"Option": "Option is deprecated. Migrate all Option usage to Maybe.",
		"Either": "Either is for branching, not errors. Migrate error handling to Result.",
		"doNotation": "Do-notation helpers provide imperative syntax for monadic code - use when chains become unreadable."
	},
	"futureWork": {
		"auditor": "When Auditor is ready, all handwritten tests will be replaced with generated proof-based tests",
		"completion": [
			"Complete Writer monad implementation",
			"Complete Future monad implementation",
			"Add missing test coverage to all monads",
			"Standardize all documentation to Envoy format",
			"Add property-based law verification"
		]
	}
}
