//++ Parse source code with semantic analysis
import type { SemanticAst } from "../../../../types/semantics/index.ts"

// Import the WASM module (generated by wasm-pack for bundler target)
// @ts-ignore - This will be generated by wasm-pack build
import { parse_with_semantics } from "../pkg/arborist_deno_ast_wasm.js"

import _convertWasmSemanticInfo from "../_convertWasmSemanticInfo/index.ts"

// Types for WASM interop
type WasmSemanticInfo = {
	"inferred_types": Record<string, string>
	purity: {
		"is_pure": boolean
		reasons: string[]
		"side_effects": string[]
	}
	complexity: {
		cyclomatic: number
		cognitive: number
		halstead: {
			volume: number
			difficulty: number
			effort: number
		}
	}
	"mathematical_properties": {
		commutative?: boolean
		associative?: boolean
		idempotent?: boolean
		distributive?: boolean
		invertible?: boolean
	}
	"symbol_table": Record<string, unknown>
	diagnostics: unknown[]
	"type_dependencies": Record<string, string[]>
}

type WasmSemanticAst = {
	module: unknown
	"source_text": string
	"file_path": string
	"semantic_info": WasmSemanticInfo
}

export default async function parseWithSemantics(
	sourceText: string,
	filePath: string,
): Promise<SemanticAst> {
	try {
		// Call the WASM function
		const result = await parse_with_semantics(sourceText, filePath)

		// The WASM function returns a JsValue that we need to convert
		const wasmResult = result as WasmSemanticAst

		// Convert WASM result to our SemanticAst type
		const semanticAst: SemanticAst = {
			module: wasmResult.module ?? {},
			sourceText: wasmResult["source_text"] ?? sourceText,
			filePath: wasmResult["file_path"] ?? filePath,
			semanticInfo: _convertWasmSemanticInfo(wasmResult["semantic_info"]),
		}

		return semanticAst
	} catch (error) {
		throw new Error(`WASM parsing failed: ${error}`)
	}
}
