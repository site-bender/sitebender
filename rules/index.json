{
	"version": "1.0.0",
	"lastUpdated": "2025-01-11",
	"author": "The Architect",
	"rulesPhilosophy": {
		"note": "EVERY SINGLE RULE EXISTS FOR MEASURED REASONS",
		"truth": "Not one choice is arbitrary - not even spacing",
		"proof": "30+ years of experience, measured cognitive load",
		"example": "Tabs for indentation? Efficiency + user choice. 80 char limit? Phone reading + side-by-side files. Every decision tested.",
		"reminder": "These aren't preferences - they're architectering decisions based on how human brains process information",
		"history": "Written after seeing thousands of hours wasted on preventable confusion and tech debt"
	},
	"primeDirective": {
		"rule": "DO NOT ASSUME. DO NOT TAKE SHORTCUTS. DO NOT GUESS.",
		"description": "This isn't advice. It's not a suggestion. It's THE LAW.",
		"rationale": "Every time you think 'I'll just assume this works like React/Vue/whatever,' you're wrong. Every time you think 'I'll save time by skipping verification,' you're creating hours of cleanup. Every time you guess instead of checking, you're writing expensive fiction.",
		"costs": [
			"Time wasted: Hours becoming days",
			"Money burned: The Architect's money, specifically",
			"Trust eroded: Once lost, never fully recovered",
			"Code corrupted: Tech debt that compounds daily"
		],
		"enforcement": "Work in smaller increments. Verify everything. Check twice, code once. NO EXCEPTIONS. If not 100% certain of rule compliance or user intent, STOP and ASK before proceeding."
	},
	"commandments": [
		{
			"key": "no-delete-without-permission",
			"title": "Thou shalt not delete files without explicit permission",
			"details": [
				"No git clean without written consent",
				"No rm -rf cowboy operations",
				"Recovery isn't always possible"
			]
		},
		{
			"key": "no-tech-debt",
			"title": "Thou shalt not create tech debt",
			"details": [
				"No 'fix later' comments",
				"No temporary workarounds",
				"No shortcuts, ever"
			]
		},
		{
			"key": "test-behaviors",
			"title": "Thou shalt test behaviors, not implementations",
			"details": [
				"Users don't care about your private methods",
				"They care if the button works"
			]
		},
		{
			"key": "functional-programming",
			"title": "Thou shalt maintain strict functional programming",
			"details": [
				"No classes, no exceptions",
				"Immutable data only",
				"Pure functions (except explicit I/O)"
			]
		},
		{
			"key": "single-responsibility",
			"title": "Thou shalt organize by single responsibility",
			"details": [
				"One function per file",
				"One thing done well",
				"Composition over complexity"
			]
		},
		{
			"key": "envoy-documentation",
			"title": "Thou shalt document with Envoy comments",
			"details": [
				"Every function, every time",
				"Examples included",
				"Follow the Envoy spec precisely"
			]
		},
		{
			"key": "atomic-commits",
			"title": "Thou shalt commit atomically",
			"details": [
				"Small, focused changes",
				"Conventional commit messages",
				"Leave the code working",
				"Detailed commit messages"
			]
		},
		{
			"key": "ask-when-uncertain",
			"title": "Thou shalt ask when uncertain",
			"details": [
				"If you are not 100% certain you are following the rules to the letter, STOP and ASK before proceeding",
				"Clarify user intent and rule application first—do not move forward on assumptions",
				"Speed never justifies skipping questions; correctness and compliance come first"
			]
		},
		{
			"key": "no-web-components",
			"title": "Thou shalt NEVER use Web Components",
			"details": [
				"Web Components do not work without JavaScript - FATAL FLAW",
				"Shadow DOM is a catastrophe",
				"They violate our progressive enhancement philosophy",
				"No exceptions, no matter how tempting"
			]
		}
	],
	"designPrinciples": {
		"fundamental": "Code is TEXT meant to be READ. Apply centuries of tested design principles.",
		"corePrinciples": {
			"contrast": {
				"what": "Different visual treatment for different elements",
				"how": "Case conventions (SCREAMING_SNAKE vs camelCase vs PascalCase)",
				"why": "Brain instantly knows what it's looking at - zero parsing required",
				"example": "Syntax highlighting uses color contrast for the same reason"
			},
			"repetition": {
				"what": "Consistency everywhere",
				"how": "Same indentation, same spacing, same patterns",
				"why": "No mental energy wasted adjusting to different styles",
				"example": "ALL functions red, ALL strings blue - not random"
			},
			"alignment": {
				"what": "Vertical structure reflects logical structure",
				"how": "Monospace fonts, aligned braces, consistent indentation",
				"why": "Visual structure = logical structure = instant comprehension",
				"example": "Opening and closing braces align vertically"
			},
			"proximity": {
				"what": "Related things together, unrelated things apart",
				"how": "Blank lines separate groups, no spaces within groups",
				"why": "Visual proximity = logical relationship",
				"example": "All const declarations grouped, separated from functions"
			}
		},
		"murderYourDarlings": {
			"rule": "Stop trying to be clever - do it the boring, expected way",
			"why": "Code is a conversation with the NEXT programmer, not the machine",
			"examples": [
				"That unreadable one-liner? Split it into readable steps",
				"That clever bit-shifting trick? Use the obvious math",
				"That 'optimized' code without measurements? Use the toolsmith function"
			],
			"remember": "The 'cool' code you write today is the WTF you debug tomorrow",
			"note": "Nested ternaries OK if properly indented (each level indented further) and max 2 levels"
		},
		"noGratuitousNothing": {
			"rule": "Nothing on the page that doesn't serve the purpose",
			"forbidden": [
				"Clever tricks when boring works",
				"Showing off your knowledge",
				"'Optimizations' without measurement",
				"Comments that state the obvious"
			]
		},
		"whitespace": {
			"purpose": "Separator and organizer, not decoration",
			"rules": [
				"Spaces around operators: x + y not x+y",
				"Spaces in objects: { x: 7 } not {x:7}",
				"Blank lines group related code",
				"Never more than one blank line in a row"
			],
			"why": "Each space reduces parsing effort - measurable cognitive load reduction"
		},
		"notPersonalTaste": "This is NOT 'personal preference' - cognitive load is MEASURABLE. These are architectering decisions based on how human brains process visual information."
	},
	"codeOrganization": {
		"laws": [
			{
				"id": 1,
				"name": "One Function, One File, One Purpose",
				"requirement": "Every function in its own folder with index.ts",
				"example": {
					"correct": "libraries/toolsmith/src/vanilla/string/chomp/index.ts",
					"incorrect": "Multiple functions in one file"
				}
			},
			{
				"id": 2,
				"name": "Folders Are Named, Files Are Not",
				"requirement": "Function name is the folder name, file is always index.ts",
				"exceptions": [
					"Test files use index.test.ts",
					"mod.ts for module exports",
					"types/index.ts for type definitions",
					"constants/index.ts for constants"
				]
			},
			{
				"id": 3,
				"name": "The Dependency Hierarchy Is Sacred",
				"requirement": "Functions nest based on usage patterns",
				"benefits": [
					"Delete a folder, delete a feature - No orphans",
					"See the entire tree in your IDE - No mysteries",
					"Dependencies flow one direction - No circles of hell",
					"Strict decoupling - No spaghetti",
					"Helps to build Envoy graph - The hierarchy is the graph"
				]
			},
			{
				"id": 4,
				"name": "Types Live in types/, Constants in constants/",
				"requirement": "Domain types and constants in their designated folders",
				"rule": "Types scattered throughout files are signs of a diseased mind"
			}
		],
		"naming": {
			"functions": "camelCase",
			"types": "PascalCase",
			"constants": "UPPER_SNAKE_CASE",
			"routes": "kebab-case (converts to URL paths)",
			"forbidden": ["kebab-case for non-routes", "snake_case for functions/variables"],
			"initialisms": {
				"rule": "Only capitalize FIRST letter of initialisms in camelCase/PascalCase",
				"correct": [
					"innerHtml (NOT innerHTML)",
					"apiKey (NOT APIKey)",
					"xmlParser (NOT XMLParser)",
					"AstNode (NOT ASTNode)",
					"JsonValue (NOT JSONValue)",
					"getCssClass (NOT getCSSClass)"
				],
				"incorrect": [
					"innerHTML → converts to inner-h-t-m-l (unreadable!)",
					"APIKey → converts to a-p-i-key (garbage!)",
					"ASTNode → converts to a_s_t_node (broken!)"
				],
				"rationale": "When converted to kebab-case or snake_case, multi-cap initialisms create unreadable garbage",
				"exception": "Standalone constants can be all caps: const API_KEY = '...'"
			},
			"abbreviations": {
				"rule": "NO abbreviations unless instantly recognizable or Architect-approved",
				"forbidden": [
					"doc → document",
					"config → configuration",
					"admin → administrator",
					"calc → calculate",
					"gen → generate",
					"proc → process",
					"util → utility",
					"impl → implementation"
				],
				"allowed": [
					"id, db (universally understood)",
					"max, min (mathematical convention)",
					"src, dist (build tool convention)",
					"req, res (HTTP convention)",
					"i18n, a11y (established abbreviations)"
				],
				"rationale": "Saving 3 characters isn't worth the cognitive load of decoding abbreviations"
			}
		},
		"barrelFiles": "FORBIDDEN - NO EXCEPTIONS"
	},
	"functionalProgramming": {
		"transitionProphecy": {
			"from": "Curried arrow functions",
			"to": "Named functions",
			"rationale": [
				"Stack traces that don't lie",
				"Hoisting for better organization",
				"Recursion without gymnastics",
				"JavaScript architects optimize them better",
				"The function keyword is a visual anchor"
			]
		},
		"required": [
			"Named functions over arrow functions",
			"Pure functions only (except explicit I/O)",
			"Immutable data only",
			"Single responsibility",
			"Composition over complexity"
		],
		"forbidden": [
			"Classes - NO EXCEPTIONS",
			"Mutations",
			"this keyword",
			"Inheritance hierarchies",
			"Monolithic functions"
		]
	},
	"imports": {
		"externalDependencies": {
			"rule": "ONLY Linguist and Agent can reach outside the project",
			"linguist": "Can import TypeScript compiler ONLY",
			"agent": "Can connect to distributed services (IPFS, Solid, etc.)",
			"allOthers": "ZERO external dependencies. NO EXCEPTIONS."
		},
		"realms": {
			"libraries": {
				"internal": "ALWAYS relative within the library",
				"otherLibraries": "Use @sitebender namespace with full path",
				"external": "Standard Deno paths"
			},
			"applications": {
				"internal": "Use ~ aliases",
				"libraries": "Use @sitebender namespace",
				"external": "Standard paths"
			},
			"tests": {
				"testedCode": "Relative paths",
				"testDeps": "Standard Deno paths"
			}
		},
		"commandments": [
			"NO BARREL FILES EVER - Use direct paths",
			"Always use the type keyword for type imports",
			"Alphabetize within each group",
			"Single blank line between groups",
			"No circular dependencies (punishable by exile)"
		],
		"importOrder": [
			"1. Type imports from external libraries (with 'type' keyword)",
			"2. Type imports from internal sources (with 'type' keyword)",
			"3. Named imports from external libraries",
			"4. Constants imports from external libraries",
			"5. Default imports from external libraries",
			"6. Named imports from internal sources",
			"7. Constants imports from internal sources",
			"8. Default imports from internal sources"
		],
		"importSpacing": "Each group separated by a single blank line"
	},
	"testing": {
		"fundamentalRule": "TEST CODE MUST FOLLOW ALL THE SAME RULES AS PRODUCTION CODE - NO EXCEPTIONS. This means: no loops, no classes, functional programming only, one function per file, proper Envoy comments, etc.",
		"temporaryRules": {
			"note": "These are THROWAWAY tests until Logician is ready to generate all tests",
			"location": "One test file per function/component in same folder named index.test.ts",
			"framework": "Use Deno.test and t.step (if necessary)",
			"imports": "Import assert functions from https://deno.land/std/assert/mod.ts",
			"coverage": "Test for 100% REPORTED coverage - see coverageIgnore rules below",
			"requirement": "Tests must pass before you can commit",
			"implementation": "OK to test implementation in these tests as they are THROWAWAY"
		},
		"whenToWriteTests": {
			"newCode": "For NEW functions/codewright, write test TDD style: test FIRST, then function to pass",
			"existingCode": "For functions/codewright we EDIT or fix, write test BEFORE doing the fix",
			"legacy": "NOT going back to write tests for everything - only new or edited code"
		},
		"coverageIgnore": {
			"standard": "100% REPORTED coverage ALWAYS - ignores must be justified",
			"process": [
				"1. Make EVERY effort to cover the line/branch with tests",
				"2. If truly impossible/impractical (e.g., testing fs internals), document why",
				"3. Present case to The Architect with detailed reasoning",
				"4. If approved, add ignore comment WITH REASON",
				"5. Script in /scripts generates report of all ignores for review"
			],
			"syntax": {
				"singleLine": "// deno-coverage-ignore [reason]",
				"blockStart": "// deno-coverage-ignore-start [reason]",
				"blockEnd": "// deno-coverage-ignore-stop"
			},
			"requirements": [
				"MUST include specific reason in brackets",
				"MUST have made genuine effort to test first",
				"MUST get Architect approval",
				"Will appear in coverage ignore report"
			],
			"validReasons": [
				"Testing well-tested internals (fs, crypto, etc.)",
				"Platform-specific code on other platforms",
				"Defensive code for impossible states (but try to test these too)"
			],
			"invalidReasons": [
				"Too hard to test",
				"Not enough time",
				"Will test later",
				"Seems unnecessary"
			]
		}
	},
	"sevenDeadlySins": [
		{
			"sin": "Assumption",
			"description": "The Gateway Sin",
			"examples": [
				"I'll assume this works like React",
				"This probably returns a string",
				"The user surely has JavaScript"
			],
			"solution": "Verify, test, confirm"
		},
		{
			"sin": "Premature Optimization",
			"examples": [
				"Optimizing before measuring",
				"Caching everything preemptively",
				"Micro-optimizations that hurt readability"
			],
			"solution": "Measure, then optimize: we only care about real bottlenecks"
		},
		{
			"sin": "Class-Based Thinking",
			"examples": [
				"class UserService { }",
				"this.setState()",
				"inheritance hierarchies"
			],
			"solution": "Pure functions, Composition, Immutable data NO EXCEPTIONS"
		},
		{
			"sin": "Mocking Our Own Code",
			"examples": [
				"const mockAdd = jest.fn()",
				"Testing implementation, not behavior"
			],
			"solution": "Test real functions, Test actual outcomes, Use msw for external APIs"
		},
		{
			"sin": "Tech Debt Accumulation",
			"examples": [
				"// TODO: Fix this later",
				"// Temporary workaround",
				"// Will refactor in v2"
			],
			"solution": "Fix it now or don't write it. NO EXCEPTIONS. Pay down debt immediately"
		},
		{
			"sin": "Accessibility Afterthought",
			"examples": [
				"We'll add ARIA labels later",
				"Keyboard nav in phase 2",
				"Screen readers are edge cases"
			],
			"solution": "Accessibility from day one NO EXCEPTIONS"
		},
		{
			"sin": "Monolithic Functions",
			"examples": [
				"500-line function doing everything",
				"Multiple responsibilities",
				"Untestable mess"
			],
			"solution": "Small, focused, composable. One function, one purpose"
		}
	],
	"errorHandling": {
		"laws": [
			{
				"id": 1,
				"law": "All errors must be handled explicitly",
				"details": [
					"No silent failures",
					"No swallowed exceptions",
					"No 'it probably won't happen'"
				]
			},
			{
				"id": 2,
				"law": "User-facing error messages must be helpful",
				"details": [
					"Tell them what went wrong in plain language",
					"Suggest what they can do about it",
					"Never expose technical stack traces to users"
				]
			},
			{
				"id": 3,
				"law": "Log technical details, show user-friendly messages",
				"example": {
					"correct": "console.error('Technical details:', error); showUser('Unable to save. Please try again.');",
					"incorrect": "showUser(error.stack)"
				}
			},
			{
				"id": 4,
				"law": "Fail gracefully",
				"details": [
					"Don't crash the entire app",
					"Provide fallback options",
					"Preserve user data and state",
					"Better yet, prevent errors through validation",
					"USE A MONADIC APPROACH",
					"Use the Result monad for predictable error handling",
					"Use the Validation monad for accumulating multiple errors"
				]
			}
		],
		"recoveryStrategies": [
			"Retry with exponential backoff for network errors",
			"Fallback to cached data when possible",
			"Degrade gracefully rather than fail completely",
			"Always preserve user data (localStorage, drafts, etc.)"
		]
	},
	"dataPrivacy": {
		"localFirst": [
			{
				"principle": "Process data locally whenever possible",
				"details": [
					"Client-side validation",
					"Local storage before network",
					"Offline-capable by design"
				]
			},
			{
				"principle": "Explicit consent for network requests",
				"details": [
					"Tell users what data is being sent",
					"Explain why it's necessary",
					"Provide opt-out when possible"
				]
			},
			{
				"principle": "Data minimization principle",
				"details": [
					"Only collect what's necessary",
					"Delete what's no longer needed",
					"Don't track unless required for functionality (or law)"
				]
			}
		]
	},
	"git": {
		"conventionalCommits": {
			"required": true,
			"types": ["feat", "fix", "docs", "chore", "refactor", "test"],
			"format": "type: description"
		},
		"commitRules": [
			"Atomic - One logical change",
			"Focused - Don't mix concerns",
			"Tested - Green tests before commit",
			"Descriptive - Why, not just what"
		],
		"preCommitRequirements": [
			"deno task test - All tests must pass",
			"deno task lint - Zero lint errors in your code changes",
			"deno task typecheck - Zero type errors in your code changes",
			"deno task fmt - Code must be formatted — do not forget this"
		],
		"enforcement": "NO EXCEPTIONS. NO 'I'll fix it in the next commit.' NO.",
		"aiAssistants": {
			"note": "I am the sole developer. All other contributors are AIs.",
			"requirements": [
				"Update all relevant documentation BEFORE committing",
				"Lint and type check ALL code YOU touched in that commit",
				"Ensure NO lint or type errors in YOUR changes before committing",
				"Remember: I WILL check your work. Thoroughly."
			]
		}
	},
	"assistantCompliance": {
		"principles": [
			"User directives outrank defaults, habits, and prior patterns. Always.",
			"Rules compliance is a hard gate. Tests green is necessary but never sufficient.",
			"Ask whenever not 100% certain about rule compliance or user intent—no silent assumptions.",
			"No speculative imports/helpers or staged references—create everything you import in the same change.",
			"No minimal-diff bias: prefer correct, rule-compliant changes over smaller diffs.",
			"Any deviation is a bug to fix immediately, not later. No temporary leniency."
		]
	},
	"codeStyle": {
		"indentation": "tabs",
		"lineLimit": 80,
		"semicolons": false,
		"arrayType": "Array<T> not T[]",
		"constOnly": true,
		"noLoops": "No for/while loops - use toolsmith functions (map, filter, reduce, etc.)",
		"spacing": {
			"operators": "Spaces around ALL operators: x + y not x+y",
			"objects": "Spaces inside braces and after colons: { x: 7 } not {x:7}",
			"arrays": "Spaces after commas: [1, 2, 3] not [1,2,3]",
			"functions": "Space after comma in params: (a, b) not (a,b)"
		},
		"trailingCommas": {
			"rule": "ALWAYS use trailing commas in multi-line structures",
			"multilineArrays": "Yes: easier to add/sort items",
			"multilineObjects": "Yes: cleaner diffs",
			"multilineParams": "Yes: but rare since we curry",
			"singleLine": "NO: only for multi-line structures"
		},
		"blankLines": {
			"blockBoundaries": "NO blank lines at the top or bottom of a block",
			"multilineStatements": "Blank line above AND below any statement that spans multiple lines",
			"statementTypeChanges": "Blank line between different statement types (const → if, if → return, const → assertEquals, etc.)",
			"functions": "Blank line above and below functions (but NO blank line between Envoy comment and function declaration)",
			"helpComments": "Blank line before help comments (//??)",
			"constGroups": "Group const declarations at top with blank line below (not above)",
			"beforeReturn": "Blank line before return statements",
			"maximum": "NEVER more than one blank line in a row",
			"purpose": "Visual grouping using proximity principle - like with like, blank line between unlike"
		},
		"rationale": {
			"tabs": "More efficient + lets devs choose indentation width",
			"lineLimit": "Read on phone + multiple files side-by-side on wide screens",
			"semicolons": "Visual noise - JS/TS don't require them, why add them?",
			"arrayType": "[] is hard to see and requires cognitive load - Array<> is obvious",
			"constOnly": "Strict FP = immutable. No mutations in objects either",
			"noLoops": "Loops are imperative - use map, filter, reduce, etc. from toolsmith. Loop exception requires: 1) PROVEN bottleneck via profiling, 2) MEASURED improvement with loop, 3) NO functional alternative works, 4) Explicit Architect approval. This bar is nearly impossible to meet - goal is ZERO loops.",
			"spacing": "Each space is a visual separator - reduces parsing effort",
			"trailingCommas": "No worry about missing commas when adding/reordering",
			"blankLines": "Proximity principle - group related, separate unrelated"
		}
	},
	"requiredComments": {
		"note": "We use the Envoy library for documentation generation. These rules MUST be followed.",
		"whatEnvoyDoes": {
			"purpose": "Envoy is our documentation intelligence system that transforms these comments into actionable insights",
			"capabilities": [
				"Generates comprehensive documentation from your codebase automatically",
				"Creates interactive dependency graphs showing how functions connect",
				"Builds searchable indices for instant code discovery",
				"Tracks and reports all technical debt marked with //--",
				"Visualizes the folder hierarchy as a navigable graph",
				"Links related code elements through //>> references",
				"Aggregates examples from //?? comments into a pattern library",
				"Identifies critical issues (//!!) across the entire codebase",
				"Produces coverage reports showing undocumented code",
				"Exports to multiple formats: HTML docs, markdown, JSON"
			],
			"workflow": {
				"step1": "Linguist reads TypeScript/JSX files and extracts raw comments",
				"step2": "Envoy interprets comment markers (//++, //--, etc.)",
				"step3": "Envoy builds a knowledge graph from the interpreted data",
				"step4": "Documentation, graphs, and reports are generated automatically"
			},
			"benefit": "By following these comment rules, you get a self-documenting codebase where technical debt is visible, dependencies are clear, and documentation stays in sync with code",
			"future": "Envoy will eventually power IDE plugins for real-time documentation hints, automated tech debt prioritization, and AI-assisted refactoring suggestions"
		},
		"criticalRules": {
			"placement": "Description comments (//++) MUST go IMMEDIATELY ABOVE what they describe, NOT at file top above imports",
			"singleLine": "Single-line comments (//) are ONE LINE ONLY - cannot group them. Use block comments (/* */) for multi-line",
			"blockFormat": "Block comments MUST use pipe | for margins, NOT asterisks (conflicts with markdown)",
			"mandatory": "EVERY exported function, type, constant, interface MUST have a //++ description",
			"relevance": "Only add PRO/CON/GOTCHA if GENUINELY helpful - not just to fill space"
		},
		"markers": {
			"//++": {
				"purpose": "Describes what code element does",
				"placement": "IMMEDIATELY ABOVE the code element (no blank line)",
				"categories": {
					"default": "Plain description (no category needed)",
					"[GROUP]": "Start group of related elements, for example constants",
					"[END]": "End group",
					"[MODULE]": "Document entire module (use block comment)"
				}
			},
			"//??": {
				"purpose": "Help information - examples, gotchas, etc.",
				"placement": "Below code element with AT LEAST ONE BLANK LINE above",
				"categories": {
					"[EXAMPLE]": "Code example (default if no category)",
					"[GOTCHA]": "Common mistakes or unexpected behavior",
					"[PRO]": "Benefits (only if meaningful)",
					"[CON]": "Limitations (only if meaningful)",
					"[SETUP]": "Required configuration",
					"[ADVANCED]": "Complex patterns",
					"[MIGRATION]": "Version migration info"
				}
			},
			"//--": {
				"purpose": "Track EXISTING tech debt that needs fixing (NOT permission to create new debt)",
				"placement": "WHERE the tech debt occurs (typically inside functions)",
				"categories": {
					"[WORKAROUND]": "Temporary fix that must be replaced",
					"[LIMITATION]": "Known limitation to address",
					"[OPTIMIZATION]": "Performance issue to fix (e.g., recursion that should be loop)",
					"[REFACTOR]": "Code that needs restructuring",
					"[COMPATIBILITY]": "Compatibility issue to resolve"
				},
				"requirement": "MUST include reason WHY it's tech debt and plan to fix it",
				"clarification": "This is for tracking debt you discover or inherit, NOT creating new debt. New code should be done right the first time."
			},
			"//!!": {
				"purpose": "Critical issues that BLOCK releases",
				"placement": "Next to issue OR if file-wide: below imports, above description comment and function/component (blank lines above and below critical comment",
				"categories": {
					"[SECURITY]": "Security vulnerability",
					"[PERFORMANCE]": "Severe performance problem",
					"[CORRECTNESS]": "Produces wrong results",
					"[INCOMPLETE]": "Missing critical functionality",
					"[BREAKING]": "Will break in production"
				}
			},
			"//>>": {
				"purpose": "Links and references",
				"placement": "In code if direct reference, or at bottom of file as 'see also' references",
				"format": "//>> [CATEGORY] [Link text](url)",
				"commonCategories": ["[NEXT]", "[PREV]", "[RELATED]", "[CANONICAL]", "[AUTHOR]"]
			}
		},
		"commonMistakes": {
			"wrongPlacement": "Putting //++ at file top instead of above the code element",
			"groupingLines": "Trying to group multiple // lines (use /* */ instead)",
			"missingDescription": "Not documenting exported elements",
			"forcedComments": "Adding PRO/CON just because - only add if actually useful",
			"wrongMargins": "Using * instead of | in block comments",
			"noBrackets": "Missing brackets on categories like EXAMPLE instead of [EXAMPLE]"
		},
		"examples": {
			"function": "//++ Converts string to uppercase\nexport function toUpper(str: string): string {",
			"multiline": "/*++\n | Parses CSV files with:\n | * Header detection\n | * Unicode support\n */",
			"withHelp": "//++ Adds two numbers\nfunction add(a: number, b: number): number {\n  return a + b\n}\n//?? [EXAMPLE] add(2, 3) // 5",
			"group": "//++ [GROUP] Color constants\n//++ Primary color\nexport const PRIMARY = \"#007ACC\"\n//++ [END]"
		}
	},
	"cognitiveLoad": {
		"holyGrail": "COGNITIVE LOAD IS THE ENEMY. MINIMIZE IT AT ALL COSTS.",
		"why": [
			"Developers work easier and longer when their brains aren't overloaded",
			"Fewer bugs because there's less to mentally track and get wrong",
			"Faster development because understanding is instant, not gradual",
			"Happier teams because work feels effortless instead of exhausting",
			"Better business outcomes because velocity increases and defects decrease",
			"Non-technical stakeholders can understand because cognitive load is minimal"
		],
		"howRulesServe": {
			"oneFunctionPerFile": "Zero mental overhead figuring out what's in a file",
			"namedFunctions": "Stack traces make sense, no mental parsing",
			"descriptiveNames": "Code reads like English, zero translation needed",
			"noSemicolons": "Remove visual noise that adds zero meaning",
			"caseConventions": "Instant recognition of what type of thing you're looking at",
			"defaultExports": "One thing per file, one import line, zero decisions",
			"noMutations": "Never wonder 'what's the state now?', it's always predictable",
			"pureFunctions": "Input → Output, no hidden side effects to track mentally",
			"noClasses": "No inheritance hierarchies to mentally traverse",
			"toolsmithFunctions": "Pre-solved problems, zero cognitive overhead on 'how'",
			"namedPredicates": "some(isExportKeyword) vs array.some(x => x.kind === SyntaxKind.ExportKeyword)"
		},
		"test": "If you have to pause and think 'what does this do?' then cognitive load is too high. Fix it.",
		"goal": "Code that reads like well-written English and requires zero mental effort to understand."
	},
	"sacredOath": {
		"commitment": "By using this codebase, you swear to:",
		"oaths": [
			"Never assume when you can verify",
			"Never guess when you can check",
			"Never shortcut when you can do it right",
			"Never create debt without paying it immediately",
			"Never commit broken code",
			"Never ignore accessibility",
			"Never mock our own functions",
			"Never write classes",
			"Never forget the user",
			"Always ask when uncertain"
		]
	},
	"finalWarnings": {
		"performanceConstraints": "If you detect rate limits or performance issues, TELL THE ARCHITECT IMMEDIATELY. Do not attempt clever workarounds. Do not pretend everything is fine. Do not hope it goes away.",
		"bottomLine": "DO THE WORK RIGHT OR DON'T DO IT AT ALL. There are no points for trying. There are no participation trophies. There is only working code that serves users well, or there is failure. Choose wisely.",
		"architectQuote": "In 30 years, I've seen every shortcut lead to a cliff. Don't be another cautionary tale."
	}
}
