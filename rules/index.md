# Project rules

> **GENERATED FILE - DO NOT EDIT**
> 
> This file is automatically generated from `rules/index.json`.
> To make changes, edit the JSON file and run `deno task generate-rules`.

**Version**: 1.0.0  
**Last updated**: 2025-01-11  
**Author**: The Architect
## Rules philosophy

<dl>
<div>
<dt><strong>Note</strong></dt>
<dd>EVERY SINGLE RULE EXISTS FOR MEASURED REASONS</dd>
</div>
<div>
<dt><strong>Truth</strong></dt>
<dd>Not one choice is arbitrary - not even spacing</dd>
</div>
<div>
<dt><strong>Proof</strong></dt>
<dd>30+ years of experience, measured cognitive load</dd>
</div>
<div>
<dt><strong>Example</strong></dt>
<dd>Tabs for indentation? Efficiency + user choice. 80 char limit? Phone reading + side-by-side files. Every decision tested.</dd>
</div>
<div>
<dt><strong>Reminder</strong></dt>
<dd>These aren't preferences - they're architectering decisions based on how human brains process information</dd>
</div>
<div>
<dt><strong>History</strong></dt>
<dd>Written after seeing thousands of hours wasted on preventable confusion and tech debt</dd>
</div>
</dl>

## Prime directive

**Rule**: DO NOT ASSUME. DO NOT TAKE SHORTCUTS. DO NOT GUESS.

**Description**: This isn't advice. It's not a suggestion. It's THE LAW.

**Rationale**: Every time you think 'I'll just assume this works like React/Vue/whatever,' you're wrong. Every time you think 'I'll save time by skipping verification,' you're creating hours of cleanup. Every time you guess instead of checking, you're writing expensive fiction.

**Costs**:
- Time wasted: Hours becoming days
- Money burned: The Architect's money, specifically
- Trust eroded: Once lost, never fully recovered
- Code corrupted: Tech debt that compounds daily

**Enforcement**: Work in smaller increments. Verify everything. Check twice, code once. NO EXCEPTIONS.

## Commandments

1. **Key**: no-delete-without-permission

**Title**: Thou shalt not delete files without explicit permission

**Details**:
- No git clean without written consent
- No rm -rf cowboy operations
- Recovery isn't always possible

2. **Key**: no-tech-debt

**Title**: Thou shalt not create tech debt

**Details**:
- No 'fix later' comments
- No temporary workarounds
- No shortcuts, ever

3. **Key**: test-behaviors

**Title**: Thou shalt test behaviors, not implementations

**Details**:
- Users don't care about your private methods
- They care if the button works

4. **Key**: functional-programming

**Title**: Thou shalt maintain strict functional programming

**Details**:
- No classes, no exceptions
- Immutable data only
- Pure functions (except explicit I/O)

5. **Key**: single-responsibility

**Title**: Thou shalt organize by single responsibility

**Details**:
- One function per file
- One thing done well
- Composition over complexity

6. **Key**: envoy-documentation

**Title**: Thou shalt document with Envoy comments

**Details**:
- Every function, every time
- Examples included
- Follow the Envoy spec precisely

7. **Key**: atomic-commits

**Title**: Thou shalt commit atomically

**Details**:
- Small, focused changes
- Conventional commit messages
- Leave the code working
- Detailed commit messages

8. **Key**: ask-when-uncertain

**Title**: Thou shalt ask when uncertain

**Details**:
- Better to ask than assume
- Better to clarify than cleanup
- Better to be slow and right

9. **Key**: no-web-components

**Title**: Thou shalt NEVER use Web Components

**Details**:
- Web Components do not work without JavaScript - FATAL FLAW
- Shadow DOM is a catastrophe
- They violate our progressive enhancement philosophy
- No exceptions, no matter how tempting

## Design principles

**Fundamental**: Code is TEXT meant to be READ. Apply centuries of tested design principles.

**Core principles**: **Contrast**: <dl>
<div>
<dt><strong>What</strong></dt>
<dd>Different visual treatment for different elements</dd>
</div>
<div>
<dt><strong>How</strong></dt>
<dd>Case conventions (SCREAMING_SNAKE vs camelCase vs PascalCase)</dd>
</div>
<div>
<dt><strong>Why</strong></dt>
<dd>Brain instantly knows what it's looking at - zero parsing required</dd>
</div>
<div>
<dt><strong>Example</strong></dt>
<dd>Syntax highlighting uses color contrast for the same reason</dd>
</div>
</dl>

**Repetition**: <dl>
<div>
<dt><strong>What</strong></dt>
<dd>Consistency everywhere</dd>
</div>
<div>
<dt><strong>How</strong></dt>
<dd>Same indentation, same spacing, same patterns</dd>
</div>
<div>
<dt><strong>Why</strong></dt>
<dd>No mental energy wasted adjusting to different styles</dd>
</div>
<div>
<dt><strong>Example</strong></dt>
<dd>ALL functions red, ALL strings blue - not random</dd>
</div>
</dl>

**Alignment**: <dl>
<div>
<dt><strong>What</strong></dt>
<dd>Vertical structure reflects logical structure</dd>
</div>
<div>
<dt><strong>How</strong></dt>
<dd>Monospace fonts, aligned braces, consistent indentation</dd>
</div>
<div>
<dt><strong>Why</strong></dt>
<dd>Visual structure = logical structure = instant comprehension</dd>
</div>
<div>
<dt><strong>Example</strong></dt>
<dd>Opening and closing braces align vertically</dd>
</div>
</dl>

**Proximity**: <dl>
<div>
<dt><strong>What</strong></dt>
<dd>Related things together, unrelated things apart</dd>
</div>
<div>
<dt><strong>How</strong></dt>
<dd>Blank lines separate groups, no spaces within groups</dd>
</div>
<div>
<dt><strong>Why</strong></dt>
<dd>Visual proximity = logical relationship</dd>
</div>
<div>
<dt><strong>Example</strong></dt>
<dd>All const declarations grouped, separated from functions</dd>
</div>
</dl>

**Murder your darlings**: **Rule**: Stop trying to be clever - do it the boring, expected way

**Why**: Code is a conversation with the NEXT programmer, not the machine

**Examples**:
- That unreadable one-liner? Split it into readable steps
- That clever bit-shifting trick? Use the obvious math
- That 'optimized' code without measurements? Use the toolsmith function

**Remember**: The 'cool' code you write today is the WTF you debug tomorrow

**Note**: Nested ternaries OK if properly indented (each level indented further) and max 2 levels

**No gratuitous nothing**: **Rule**: Nothing on the page that doesn't serve the purpose

**Forbidden**:
- Clever tricks when boring works
- Showing off your knowledge
- 'Optimizations' without measurement
- Comments that state the obvious

**Whitespace**: **Purpose**: Separator and organizer, not decoration

**Rules**:
- Spaces around operators: x + y not x+y
- Spaces in objects: { x: 7 } not {x:7}
- Blank lines group related code
- Never more than one blank line in a row

**Why**: Each space reduces parsing effort - measurable cognitive load reduction

**Not personal taste**: This is NOT 'personal preference' - cognitive load is MEASURABLE. These are architectering decisions based on how human brains process visual information.

## Code organization

**Laws**:
1. **Id**: 1

**Name**: One Function, One File, One Purpose

**Requirement**: Every function in its own folder with index.ts

**Example**: <dl>
<div>
<dt><strong>Correct</strong></dt>
<dd>libraries/toolsmith/src/vanilla/string/chomp/index.ts</dd>
</div>
<div>
<dt><strong>Incorrect</strong></dt>
<dd>Multiple functions in one file</dd>
</div>
</dl>

2. **Id**: 2

**Name**: Folders Are Named, Files Are Not

**Requirement**: Function name is the folder name, file is always index.ts

**Exceptions**:
- Test files use index.test.ts
- mod.ts for module exports
- types/index.ts for type definitions
- constants/index.ts for constants

3. **Id**: 3

**Name**: The Dependency Hierarchy Is Sacred

**Requirement**: Functions nest based on usage patterns

**Benefits**:
- Delete a folder, delete a feature - No orphans
- See the entire tree in your IDE - No mysteries
- Dependencies flow one direction - No circles of hell
- Strict decoupling - No spaghetti
- Helps to build Envoy graph - The hierarchy is the graph

4. **Id**: 4

**Name**: Types Live in types/, Constants in constants/

**Requirement**: Domain types and constants in their designated folders

**Rule**: Types scattered throughout files are signs of a diseased mind

**Naming**: **Functions**: camelCase

**Types**: PascalCase

**Constants**: UPPER_SNAKE_CASE

**Routes**: kebab-case (converts to URL paths)

**Forbidden**:
- kebab-case for non-routes
- snake_case for functions/variables

**Initialisms**: **Rule**: Only capitalize FIRST letter of initialisms in camelCase/PascalCase

**Correct**:
- innerHtml (NOT innerHTML)
- apiKey (NOT APIKey)
- xmlParser (NOT XMLParser)
- AstNode (NOT ASTNode)
- JsonValue (NOT JSONValue)
- getCssClass (NOT getCSSClass)

**Incorrect**:
- innerHTML → converts to inner-h-t-m-l (unreadable!)
- APIKey → converts to a-p-i-key (garbage!)
- ASTNode → converts to a_s_t_node (broken!)

**Rationale**: When converted to kebab-case or snake_case, multi-cap initialisms create unreadable garbage

**Exception**: Standalone constants can be all caps: const API_KEY = '...'

**Abbreviations**: **Rule**: NO abbreviations unless instantly recognizable or Architect-approved

**Forbidden**:
- doc → document
- config → configuration
- admin → administrator
- calc → calculate
- gen → generate
- proc → process
- util → utility
- impl → implementation

**Allowed**:
- id, db (universally understood)
- max, min (mathematical convention)
- src, dist (build tool convention)
- req, res (HTTP convention)
- i18n, a11y (established abbreviations)

**Rationale**: Saving 3 characters isn't worth the cognitive load of decoding abbreviations

**Barrel files**: FORBIDDEN - NO EXCEPTIONS

## Functional programming

**Transition prophecy**: **From**: Curried arrow functions

**To**: Named functions

**Rationale**:
- Stack traces that don't lie
- Hoisting for better organization
- Recursion without gymnastics
- JavaScript architects optimize them better
- The function keyword is a visual anchor

**Required**:
- Named functions over arrow functions
- Pure functions only (except explicit I/O)
- Immutable data only
- Single responsibility
- Composition over complexity

**Forbidden**:
- Classes - NO EXCEPTIONS
- Mutations
- this keyword
- Inheritance hierarchies
- Monolithic functions

## Imports

**External dependencies**: <dl>
<div>
<dt><strong>Rule</strong></dt>
<dd>ONLY Arborist and Agent can reach outside the project</dd>
</div>
<div>
<dt><strong>Arborist</strong></dt>
<dd>Can import TypeScript compiler ONLY</dd>
</div>
<div>
<dt><strong>Agent</strong></dt>
<dd>Can connect to distributed services (IPFS, Solid, etc.)</dd>
</div>
<div>
<dt><strong>All others</strong></dt>
<dd>ZERO external dependencies. NO EXCEPTIONS.</dd>
</div>
</dl>

**Realms**: **Libraries**: <dl>
<div>
<dt><strong>Internal</strong></dt>
<dd>ALWAYS relative within the library</dd>
</div>
<div>
<dt><strong>Other libraries</strong></dt>
<dd>Use @sitebender namespace with full path</dd>
</div>
<div>
<dt><strong>External</strong></dt>
<dd>Standard Deno paths</dd>
</div>
</dl>

**Applications**: <dl>
<div>
<dt><strong>Internal</strong></dt>
<dd>Use ~ aliases</dd>
</div>
<div>
<dt><strong>Libraries</strong></dt>
<dd>Use @sitebender namespace</dd>
</div>
<div>
<dt><strong>External</strong></dt>
<dd>Standard paths</dd>
</div>
</dl>

**Tests**: <dl>
<div>
<dt><strong>Tested code</strong></dt>
<dd>Relative paths</dd>
</div>
<div>
<dt><strong>Test deps</strong></dt>
<dd>Standard Deno paths</dd>
</div>
</dl>

**Commandments**:
- NO BARREL FILES EVER - Use direct paths
- Separate type imports from non-type imports by a blank line
- Always use the type keyword for type imports
- Separate imports of constants from other imports with a blank line
- Alphabetize within groups
- Single blank line between groups
- No circular dependencies (punishable by exile)

## Testing

**Fundamental rule**: TEST CODE MUST FOLLOW ALL THE SAME RULES AS PRODUCTION CODE - NO EXCEPTIONS. This means: no loops, no classes, functional programming only, one function per file, proper Envoy comments, etc.

**Temporary rules**: <dl>
<div>
<dt><strong>Note</strong></dt>
<dd>These are THROWAWAY tests until Auditor is ready to generate all tests</dd>
</div>
<div>
<dt><strong>Location</strong></dt>
<dd>One test file per function/component in same folder named index.test.ts</dd>
</div>
<div>
<dt><strong>Framework</strong></dt>
<dd>Use Deno.test and t.step (if necessary)</dd>
</div>
<div>
<dt><strong>Imports</strong></dt>
<dd>Import assert functions from https://deno.land/std/assert/mod.ts</dd>
</div>
<div>
<dt><strong>Coverage</strong></dt>
<dd>Test for 100% REPORTED coverage - see coverageIgnore rules below</dd>
</div>
<div>
<dt><strong>Requirement</strong></dt>
<dd>Tests must pass before you can commit</dd>
</div>
<div>
<dt><strong>Implementation</strong></dt>
<dd>OK to test implementation in these tests as they are THROWAWAY</dd>
</div>
</dl>

**When to write tests**: <dl>
<div>
<dt><strong>New code</strong></dt>
<dd>For NEW functions/pagewright, write test TDD style: test FIRST, then function to pass</dd>
</div>
<div>
<dt><strong>Existing code</strong></dt>
<dd>For functions/pagewright we EDIT or fix, write test BEFORE doing the fix</dd>
</div>
<div>
<dt><strong>Legacy</strong></dt>
<dd>NOT going back to write tests for everything - only new or edited code</dd>
</div>
</dl>

**Coverage ignore**: **Standard**: 100% REPORTED coverage ALWAYS - ignores must be justified

**Process**:
- 1. Make EVERY effort to cover the line/branch with tests
- 2. If truly impossible/impractical (e.g., testing fs internals), document why
- 3. Present case to The Architect with detailed reasoning
- 4. If approved, add ignore comment WITH REASON
- 5. Script in /scripts generates report of all ignores for review

**Syntax**: <dl>
<div>
<dt><strong>Single line</strong></dt>
<dd>// deno-coverage-ignore [reason]</dd>
</div>
<div>
<dt><strong>Block start</strong></dt>
<dd>// deno-coverage-ignore-start [reason]</dd>
</div>
<div>
<dt><strong>Block end</strong></dt>
<dd>// deno-coverage-ignore-stop</dd>
</div>
</dl>

**Requirements**:
- MUST include specific reason in brackets
- MUST have made genuine effort to test first
- MUST get Architect approval
- Will appear in coverage ignore report

**Valid reasons**:
- Testing well-tested internals (fs, crypto, etc.)
- Platform-specific code on other platforms
- Defensive code for impossible states (but try to test these too)

**Invalid reasons**:
- Too hard to test
- Not enough time
- Will test later
- Seems unnecessary

## Seven deadly sins

1. **Sin**: Assumption

**Description**: The Gateway Sin

**Examples**:
- I'll assume this works like React
- This probably returns a string
- The user surely has JavaScript

**Solution**: Verify, test, confirm

2. **Sin**: Premature Optimization

**Examples**:
- Optimizing before measuring
- Caching everything preemptively
- Micro-optimizations that hurt readability

**Solution**: Measure, then optimize: we only care about real bottlenecks

3. **Sin**: Class-Based Thinking

**Examples**:
- class UserService { }
- this.setState()
- inheritance hierarchies

**Solution**: Pure functions, Composition, Immutable data NO EXCEPTIONS

4. **Sin**: Mocking Our Own Code

**Examples**:
- const mockAdd = jest.fn()
- Testing implementation, not behavior

**Solution**: Test real functions, Test actual outcomes, Use msw for external APIs

5. **Sin**: Tech Debt Accumulation

**Examples**:
- // TODO: Fix this later
- // Temporary workaround
- // Will refactor in v2

**Solution**: Fix it now or don't write it. NO EXCEPTIONS. Pay down debt immediately

6. **Sin**: Accessibility Afterthought

**Examples**:
- We'll add ARIA labels later
- Keyboard nav in phase 2
- Screen readers are edge cases

**Solution**: Accessibility from day one NO EXCEPTIONS

7. **Sin**: Monolithic Functions

**Examples**:
- 500-line function doing everything
- Multiple responsibilities
- Untestable mess

**Solution**: Small, focused, composable. One function, one purpose

## Error handling

**Laws**:
1. **Id**: 1

**Law**: All errors must be handled explicitly

**Details**:
- No silent failures
- No swallowed exceptions
- No 'it probably won't happen'

2. **Id**: 2

**Law**: User-facing error messages must be helpful

**Details**:
- Tell them what went wrong in plain language
- Suggest what they can do about it
- Never expose technical stack traces to users

3. **Id**: 3

**Law**: Log technical details, show user-friendly messages

**Example**: <dl>
<div>
<dt><strong>Correct</strong></dt>
<dd>console.error('Technical details:', error); showUser('Unable to save. Please try again.');</dd>
</div>
<div>
<dt><strong>Incorrect</strong></dt>
<dd>showUser(error.stack)</dd>
</div>
</dl>

4. **Id**: 4

**Law**: Fail gracefully

**Details**:
- Don't crash the entire app
- Provide fallback options
- Preserve user data and state
- Better yet, prevent errors through validation
- USE A MONADIC APPROACH
- Use the Result monad for predictable error handling
- Use the Validation monad for accumulating multiple errors

**Recovery strategies**:
- Retry with exponential backoff for network errors
- Fallback to cached data when possible
- Degrade gracefully rather than fail completely
- Always preserve user data (localStorage, drafts, etc.)

## Data privacy

**Local first**:
1. **Principle**: Process data locally whenever possible

**Details**:
- Client-side validation
- Local storage before network
- Offline-capable by design

2. **Principle**: Explicit consent for network requests

**Details**:
- Tell users what data is being sent
- Explain why it's necessary
- Provide opt-out when possible

3. **Principle**: Data minimization principle

**Details**:
- Only collect what's necessary
- Delete what's no longer needed
- Don't track unless required for functionality (or law)

## Git

**Conventional commits**: **Required**: true

**Types**:
- feat
- fix
- docs
- chore
- refactor
- test

**Format**: type: description

**Commit rules**:
- Atomic - One logical change
- Focused - Don't mix concerns
- Tested - Green tests before commit
- Descriptive - Why, not just what

**Pre commit requirements**:
- deno task test - All tests must pass
- deno task lint - Zero lint errors in your code changes
- deno task typecheck - Zero type errors in your code changes
- deno task fmt - Code must be formatted — do not forget this

**Enforcement**: NO EXCEPTIONS. NO 'I'll fix it in the next commit.' NO.

**Ai assistants**: **Note**: I am the sole developer. All other contributors are AIs.

**Requirements**:
- Update all relevant documentation BEFORE committing
- Lint and type check ALL code YOU touched in that commit
- Ensure NO lint or type errors in YOUR changes before committing
- Remember: I WILL check your work. Thoroughly.

## Code style

**Indentation**: tabs

**Line limit**: 80

**Semicolons**: false

**Array type**: Array<T> not T[]

**Const only**: true

**No loops**: No for/while loops - use toolsmith functions (map, filter, reduce, etc.)

**Spacing**: <dl>
<div>
<dt><strong>Operators</strong></dt>
<dd>Spaces around ALL operators: x + y not x+y</dd>
</div>
<div>
<dt><strong>Objects</strong></dt>
<dd>Spaces inside braces and after colons: { x: 7 } not {x:7}</dd>
</div>
<div>
<dt><strong>Arrays</strong></dt>
<dd>Spaces after commas: [1, 2, 3] not [1,2,3]</dd>
</div>
<div>
<dt><strong>Functions</strong></dt>
<dd>Space after comma in params: (a, b) not (a,b)</dd>
</div>
</dl>

**Trailing commas**: <dl>
<div>
<dt><strong>Rule</strong></dt>
<dd>ALWAYS use trailing commas in multi-line structures</dd>
</div>
<div>
<dt><strong>Multiline arrays</strong></dt>
<dd>Yes: easier to add/sort items</dd>
</div>
<div>
<dt><strong>Multiline objects</strong></dt>
<dd>Yes: cleaner diffs</dd>
</div>
<div>
<dt><strong>Multiline params</strong></dt>
<dd>Yes: but rare since we curry</dd>
</div>
<div>
<dt><strong>Single line</strong></dt>
<dd>NO: only for multi-line structures</dd>
</div>
</dl>

**Blank lines**: <dl>
<div>
<dt><strong>Const groups</strong></dt>
<dd>Group const declarations at top with blank line below (not above)</dd>
</div>
<div>
<dt><strong>Before return</strong></dt>
<dd>Blank line before return statements</dd>
</div>
<div>
<dt><strong>Around multiline</strong></dt>
<dd>Blank lines before AND after multi-line blocks/statements</dd>
</div>
<div>
<dt><strong>Maximum</strong></dt>
<dd>NEVER more than one blank line in a row</dd>
</div>
<div>
<dt><strong>Purpose</strong></dt>
<dd>Visual grouping using proximity principle</dd>
</div>
</dl>

**Rationale**: <dl>
<div>
<dt><strong>Tabs</strong></dt>
<dd>More efficient + lets devs choose indentation width</dd>
</div>
<div>
<dt><strong>Line limit</strong></dt>
<dd>Read on phone + multiple files side-by-side on wide screens</dd>
</div>
<div>
<dt><strong>Semicolons</strong></dt>
<dd>Visual noise - JS/TS don't require them, why add them?</dd>
</div>
<div>
<dt><strong>Array type</strong></dt>
<dd>[] is hard to see and requires cognitive load - Array<> is obvious</dd>
</div>
<div>
<dt><strong>Const only</strong></dt>
<dd>Strict FP = immutable. No mutations in objects either</dd>
</div>
<div>
<dt><strong>No loops</strong></dt>
<dd>Loops are imperative - use map, filter, reduce, etc. from toolsmith. Loop exception requires: 1) PROVEN bottleneck via profiling, 2) MEASURED improvement with loop, 3) NO functional alternative works, 4) Explicit Architect approval. This bar is nearly impossible to meet - goal is ZERO loops.</dd>
</div>
<div>
<dt><strong>Spacing</strong></dt>
<dd>Each space is a visual separator - reduces parsing effort</dd>
</div>
<div>
<dt><strong>Trailing commas</strong></dt>
<dd>No worry about missing commas when adding/reordering</dd>
</div>
<div>
<dt><strong>Blank lines</strong></dt>
<dd>Proximity principle - group related, separate unrelated</dd>
</div>
</dl>

## Required comments

**Note**: We use the Envoy library for documentation generation. These rules MUST be followed.

**What envoy does**: **Purpose**: Envoy is our documentation intelligence system that transforms these comments into actionable insights

**Capabilities**:
- Generates comprehensive documentation from your codebase automatically
- Creates interactive dependency graphs showing how functions connect
- Builds searchable indices for instant code discovery
- Tracks and reports all technical debt marked with //--
- Visualizes the folder hierarchy as a navigable graph
- Links related code elements through //>> references
- Aggregates examples from //?? comments into a pattern library
- Identifies critical issues (//!!) across the entire codebase
- Produces coverage reports showing undocumented code
- Exports to multiple formats: HTML docs, markdown, JSON

**Workflow**: <dl>
<div>
<dt><strong>Step 1</strong></dt>
<dd>Arborist reads TypeScript/JSX files and extracts raw comments</dd>
</div>
<div>
<dt><strong>Step 2</strong></dt>
<dd>Envoy interprets comment markers (//++, //--, etc.)</dd>
</div>
<div>
<dt><strong>Step 3</strong></dt>
<dd>Envoy builds a knowledge graph from the interpreted data</dd>
</div>
<div>
<dt><strong>Step 4</strong></dt>
<dd>Documentation, graphs, and reports are generated automatically</dd>
</div>
</dl>

**Benefit**: By following these comment rules, you get a self-documenting codebase where technical debt is visible, dependencies are clear, and documentation stays in sync with code

**Future**: Envoy will eventually power IDE plugins for real-time documentation hints, automated tech debt prioritization, and AI-assisted refactoring suggestions

**Critical rules**: <dl>
<div>
<dt><strong>Placement</strong></dt>
<dd>Description comments (//++) MUST go IMMEDIATELY ABOVE what they describe, NOT at file top above imports</dd>
</div>
<div>
<dt><strong>Single line</strong></dt>
<dd>Single-line comments (//) are ONE LINE ONLY - cannot group them. Use block comments (/* */) for multi-line</dd>
</div>
<div>
<dt><strong>Block format</strong></dt>
<dd>Block comments MUST use pipe | for margins, NOT asterisks (conflicts with markdown)</dd>
</div>
<div>
<dt><strong>Mandatory</strong></dt>
<dd>EVERY exported function, type, constant, interface MUST have a //++ description</dd>
</div>
<div>
<dt><strong>Relevance</strong></dt>
<dd>Only add PRO/CON/GOTCHA if GENUINELY helpful - not just to fill space</dd>
</div>
</dl>

**Markers**: ****: **Purpose**: Describes what code element does

**Placement**: IMMEDIATELY ABOVE the code element (no blank line)

**Categories**: <dl>
<div>
<dt><strong>Default</strong></dt>
<dd>Plain description (no category needed)</dd>
</div>
<div>
<dt><strong>Group</strong></dt>
<dd>Start group of related elements, for example constants</dd>
</div>
<div>
<dt><strong>End</strong></dt>
<dd>End group</dd>
</div>
<div>
<dt><strong>Module</strong></dt>
<dd>Document entire module (use block comment)</dd>
</div>
</dl>

****: **Purpose**: Help information - examples, gotchas, etc.

**Placement**: Below code element with AT LEAST ONE BLANK LINE above

**Categories**: <dl>
<div>
<dt><strong>Example</strong></dt>
<dd>Code example (default if no category)</dd>
</div>
<div>
<dt><strong>Gotcha</strong></dt>
<dd>Common mistakes or unexpected behavior</dd>
</div>
<div>
<dt><strong>Pro</strong></dt>
<dd>Benefits (only if meaningful)</dd>
</div>
<div>
<dt><strong>Con</strong></dt>
<dd>Limitations (only if meaningful)</dd>
</div>
<div>
<dt><strong>Setup</strong></dt>
<dd>Required configuration</dd>
</div>
<div>
<dt><strong>Advanced</strong></dt>
<dd>Complex patterns</dd>
</div>
<div>
<dt><strong>Migration</strong></dt>
<dd>Version migration info</dd>
</div>
</dl>

****: **Purpose**: Track EXISTING tech debt that needs fixing (NOT permission to create new debt)

**Placement**: WHERE the tech debt occurs (typically inside functions)

**Categories**: <dl>
<div>
<dt><strong>Workaround</strong></dt>
<dd>Temporary fix that must be replaced</dd>
</div>
<div>
<dt><strong>Limitation</strong></dt>
<dd>Known limitation to address</dd>
</div>
<div>
<dt><strong>Optimization</strong></dt>
<dd>Performance issue to fix (e.g., recursion that should be loop)</dd>
</div>
<div>
<dt><strong>Refactor</strong></dt>
<dd>Code that needs restructuring</dd>
</div>
<div>
<dt><strong>Compatibility</strong></dt>
<dd>Compatibility issue to resolve</dd>
</div>
</dl>

**Requirement**: MUST include reason WHY it's tech debt and plan to fix it

**Clarification**: This is for tracking debt you discover or inherit, NOT creating new debt. New code should be done right the first time.

****: **Purpose**: Critical issues that BLOCK releases

**Placement**: Next to issue OR if file-wide: below imports, above description comment and function/component (blank lines above and below critical comment

**Categories**: <dl>
<div>
<dt><strong>Security</strong></dt>
<dd>Security vulnerability</dd>
</div>
<div>
<dt><strong>Performance</strong></dt>
<dd>Severe performance problem</dd>
</div>
<div>
<dt><strong>Correctness</strong></dt>
<dd>Produces wrong results</dd>
</div>
<div>
<dt><strong>Incomplete</strong></dt>
<dd>Missing critical functionality</dd>
</div>
<div>
<dt><strong>Breaking</strong></dt>
<dd>Will break in production</dd>
</div>
</dl>

****: **Purpose**: Links and references

**Placement**: In code if direct reference, or at bottom of file as 'see also' references

**Format**: //>> [CATEGORY] [Link text](url)

**Common categories**:
- [NEXT]
- [PREV]
- [RELATED]
- [CANONICAL]
- [AUTHOR]

**Common mistakes**: <dl>
<div>
<dt><strong>Wrong placement</strong></dt>
<dd>Putting //++ at file top instead of above the code element</dd>
</div>
<div>
<dt><strong>Grouping lines</strong></dt>
<dd>Trying to group multiple // lines (use /* */ instead)</dd>
</div>
<div>
<dt><strong>Missing description</strong></dt>
<dd>Not documenting exported elements</dd>
</div>
<div>
<dt><strong>Forced comments</strong></dt>
<dd>Adding PRO/CON just because - only add if actually useful</dd>
</div>
<div>
<dt><strong>Wrong margins</strong></dt>
<dd>Using * instead of | in block comments</dd>
</div>
<div>
<dt><strong>No brackets</strong></dt>
<dd>Missing brackets on categories like EXAMPLE instead of [EXAMPLE]</dd>
</div>
</dl>

**Examples**: <dl>
<div>
<dt><strong>Function</strong></dt>
<dd>//++ Converts string to uppercase
export function toUpper(str: string): string {</dd>
</div>
<div>
<dt><strong>Multiline</strong></dt>
<dd>/*++
 | Parses CSV files with:
 | * Header detection
 | * Unicode support
 */</dd>
</div>
<div>
<dt><strong>With help</strong></dt>
<dd>//++ Adds two numbers
function add(a: number, b: number): number {
  return a + b
}
//?? [EXAMPLE] add(2, 3) // 5</dd>
</div>
<div>
<dt><strong>Group</strong></dt>
<dd>//++ [GROUP] Color constants
//++ Primary color
export const PRIMARY = "#007ACC"
//++ [END]</dd>
</div>
</dl>

## Cognitive load

**Holy grail**: COGNITIVE LOAD IS THE ENEMY. MINIMIZE IT AT ALL COSTS.

**Why**:
- Developers work easier and longer when their brains aren't overloaded
- Fewer bugs because there's less to mentally track and get wrong
- Faster development because understanding is instant, not gradual
- Happier teams because work feels effortless instead of exhausting
- Better business outcomes because velocity increases and defects decrease
- Non-technical stakeholders can understand because cognitive load is minimal

**How rules serve**: <dl>
<div>
<dt><strong>One function per file</strong></dt>
<dd>Zero mental overhead figuring out what's in a file</dd>
</div>
<div>
<dt><strong>Named functions</strong></dt>
<dd>Stack traces make sense, no mental parsing</dd>
</div>
<div>
<dt><strong>Descriptive names</strong></dt>
<dd>Code reads like English, zero translation needed</dd>
</div>
<div>
<dt><strong>No semicolons</strong></dt>
<dd>Remove visual noise that adds zero meaning</dd>
</div>
<div>
<dt><strong>Case conventions</strong></dt>
<dd>Instant recognition of what type of thing you're looking at</dd>
</div>
<div>
<dt><strong>Default exports</strong></dt>
<dd>One thing per file, one import line, zero decisions</dd>
</div>
<div>
<dt><strong>No mutations</strong></dt>
<dd>Never wonder 'what's the state now?', it's always predictable</dd>
</div>
<div>
<dt><strong>Pure functions</strong></dt>
<dd>Input → Output, no hidden side effects to track mentally</dd>
</div>
<div>
<dt><strong>No classes</strong></dt>
<dd>No inheritance hierarchies to mentally traverse</dd>
</div>
<div>
<dt><strong>Toolsmith functions</strong></dt>
<dd>Pre-solved problems, zero cognitive overhead on 'how'</dd>
</div>
<div>
<dt><strong>Named predicates</strong></dt>
<dd>some(isExportKeyword) vs array.some(x => x.kind === SyntaxKind.ExportKeyword)</dd>
</div>
</dl>

**Test**: If you have to pause and think 'what does this do?' then cognitive load is too high. Fix it.

**Goal**: Code that reads like well-written English and requires zero mental effort to understand.

## Sacred oath

**Commitment**: By using this codebase, you swear to:

**Oaths**:
- Never assume when you can verify
- Never guess when you can check
- Never shortcut when you can do it right
- Never create debt without paying it immediately
- Never commit broken code
- Never ignore accessibility
- Never mock our own functions
- Never write classes
- Never forget the user
- Always ask when uncertain

## Final warnings

<dl>
<div>
<dt><strong>Performance constraints</strong></dt>
<dd>If you detect rate limits or performance issues, TELL THE ARCHITECT IMMEDIATELY. Do not attempt clever workarounds. Do not pretend everything is fine. Do not hope it goes away.</dd>
</div>
<div>
<dt><strong>Bottom line</strong></dt>
<dd>DO THE WORK RIGHT OR DON'T DO IT AT ALL. There are no points for trying. There are no participation trophies. There is only working code that serves users well, or there is failure. Choose wisely.</dd>
</div>
<div>
<dt><strong>Architect quote</strong></dt>
<dd>In 30 years, I've seen every shortcut lead to a cliff. Don't be another cautionary tale.</dd>
</div>
</dl>

---

**Generated from**: `rules/index.json`  
**Generated on**: 2025-09-13T09:00:09.346Z
